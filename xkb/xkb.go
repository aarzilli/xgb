// Package xkb is the X client API for the XKEYBOARD extension.
package xkb

// This file is automatically generated from xkb.xml. Edit at your peril!

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the XKEYBOARD extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 9, "XKEYBOARD").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named XKEYBOARD could be found on on the server.")
	}

	c.ExtLock.Lock()
	c.Extensions["XKEYBOARD"] = reply.MajorOpcode
	c.ExtLock.Unlock()
	for evNum, fun := range xgb.NewExtEventFuncs["XKEYBOARD"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["XKEYBOARD"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	return nil
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["XKEYBOARD"] = make(map[int]xgb.NewErrorFun)
}

const (
	AXNDetailSKPress    = 1
	AXNDetailSKAccept   = 2
	AXNDetailSKReject   = 4
	AXNDetailSKRelease  = 8
	AXNDetailBKAccept   = 16
	AXNDetailBKReject   = 32
	AXNDetailAXKWarning = 64
)

const (
	AXOptionSKPressFB    = 1
	AXOptionSKAcceptFB   = 2
	AXOptionFeatureFB    = 4
	AXOptionSlowWarnFB   = 8
	AXOptionIndicatorFB  = 16
	AXOptionStickyKeysFB = 32
	AXOptionTwoKeys      = 64
	AXOptionLatchToLock  = 128
	AXOptionSKReleaseFB  = 256
	AXOptionSKRejectFB   = 512
	AXOptionBKRejectFB   = 1024
	AXOptionDumbBell     = 2048
)

// AccessXNotify is the event number for a AccessXNotifyEvent.
const AccessXNotify = 10

type AccessXNotifyEvent struct {
	Sequence      uint16
	XkbType       byte
	Time          xproto.Timestamp
	DeviceID      byte
	Keycode       xproto.Keycode
	Detailt       uint16
	SlowKeysDelay uint16
	DebounceDelay uint16
	// padding: 16 bytes
}

// AccessXNotifyEventNew constructs a AccessXNotifyEvent value that implements xgb.Event from a byte slice.
func AccessXNotifyEventNew(buf []byte) xgb.Event {
	v := AccessXNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	v.Keycode = xproto.Keycode(buf[b])
	b += 1

	v.Detailt = xgb.Get16(buf[b:])
	b += 2

	v.SlowKeysDelay = xgb.Get16(buf[b:])
	b += 2

	v.DebounceDelay = xgb.Get16(buf[b:])
	b += 2

	b += 16 // padding

	return v
}

// Bytes writes a AccessXNotifyEvent value to a byte slice.
func (v AccessXNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 10
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	buf[b] = byte(v.Keycode)
	b += 1

	xgb.Put16(buf[b:], v.Detailt)
	b += 2

	xgb.Put16(buf[b:], v.SlowKeysDelay)
	b += 2

	xgb.Put16(buf[b:], v.DebounceDelay)
	b += 2

	b += 16 // padding

	return buf
}

// SequenceId returns the sequence id attached to the AccessXNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v AccessXNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of AccessXNotifyEvent.
func (v AccessXNotifyEvent) String() string {
	fieldVals := make([]string, 0, 8)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("Keycode: %d", v.Keycode))
	fieldVals = append(fieldVals, xgb.Sprintf("Detailt: %d", v.Detailt))
	fieldVals = append(fieldVals, xgb.Sprintf("SlowKeysDelay: %d", v.SlowKeysDelay))
	fieldVals = append(fieldVals, xgb.Sprintf("DebounceDelay: %d", v.DebounceDelay))
	return "AccessXNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][10] = AccessXNotifyEventNew
}

// ActionMessage is the event number for a ActionMessageEvent.
const ActionMessage = 9

type ActionMessageEvent struct {
	Sequence        uint16
	XkbType         byte
	Time            xproto.Timestamp
	DeviceID        byte
	Keycode         xproto.Keycode
	Press           bool
	KeyEventFollows bool
	Mods            byte
	Group           byte
	Message         []String8 // size: 8
	// padding: 10 bytes
}

// ActionMessageEventNew constructs a ActionMessageEvent value that implements xgb.Event from a byte slice.
func ActionMessageEventNew(buf []byte) xgb.Event {
	v := ActionMessageEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	v.Keycode = xproto.Keycode(buf[b])
	b += 1

	if buf[b] == 1 {
		v.Press = true
	} else {
		v.Press = false
	}
	b += 1

	if buf[b] == 1 {
		v.KeyEventFollows = true
	} else {
		v.KeyEventFollows = false
	}
	b += 1

	v.Mods = buf[b]
	b += 1

	v.Group = buf[b]
	b += 1

	v.Message = make([]String8, 8)
	for i := 0; i < int(8); i++ {
		v.Message[i] = String8(buf[b])
		b += 1
	}

	b += 10 // padding

	return v
}

// Bytes writes a ActionMessageEvent value to a byte slice.
func (v ActionMessageEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 9
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	buf[b] = byte(v.Keycode)
	b += 1

	if v.Press {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if v.KeyEventFollows {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.Mods
	b += 1

	buf[b] = v.Group
	b += 1

	for i := 0; i < int(8); i++ {
		buf[b] = byte(v.Message[i])
		b += 1
	}

	b += 10 // padding

	return buf
}

// SequenceId returns the sequence id attached to the ActionMessage event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v ActionMessageEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of ActionMessageEvent.
func (v ActionMessageEvent) String() string {
	fieldVals := make([]string, 0, 10)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("Keycode: %d", v.Keycode))
	fieldVals = append(fieldVals, xgb.Sprintf("Press: %t", v.Press))
	fieldVals = append(fieldVals, xgb.Sprintf("KeyEventFollows: %t", v.KeyEventFollows))
	fieldVals = append(fieldVals, xgb.Sprintf("Mods: %d", v.Mods))
	fieldVals = append(fieldVals, xgb.Sprintf("Group: %d", v.Group))
	return "ActionMessage {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][9] = ActionMessageEventNew
}

const (
	ActionMessageFlagOnPress     = 1
	ActionMessageFlagOnRelease   = 2
	ActionMessageFlagGenKeyEvent = 4
)

// ActionUnion is a represention of the ActionUnion union type.
// Note that to *create* a Union, you should *never* create
// this struct directly (unless you know what you're doing).
// Instead use one of the following constructors for 'ActionUnion':
//     ActionUnionNoactionNew(Noaction SANoAction) ActionUnion
//     ActionUnionSetmodsNew(Setmods SASetMods) ActionUnion
//     ActionUnionLatchmodsNew(Latchmods SALatchMods) ActionUnion
//     ActionUnionLockmodsNew(Lockmods SALockMods) ActionUnion
//     ActionUnionSetgroupNew(Setgroup SASetGroup) ActionUnion
//     ActionUnionLatchgroupNew(Latchgroup SALatchGroup) ActionUnion
//     ActionUnionLockgroupNew(Lockgroup SALockGroup) ActionUnion
//     ActionUnionMoveptrNew(Moveptr SAMovePtr) ActionUnion
//     ActionUnionPtrbtnNew(Ptrbtn SAPtrBtn) ActionUnion
//     ActionUnionLockptrbtnNew(Lockptrbtn SALockPtrBtn) ActionUnion
//     ActionUnionSetptrdfltNew(Setptrdflt SASetPtrDflt) ActionUnion
//     ActionUnionIsolockNew(Isolock SAIsoLock) ActionUnion
//     ActionUnionTerminateNew(Terminate SATerminate) ActionUnion
//     ActionUnionSwitchscreenNew(Switchscreen SASwitchScreen) ActionUnion
//     ActionUnionSetcontrolsNew(Setcontrols SASetControls) ActionUnion
//     ActionUnionLockcontrolsNew(Lockcontrols SALockControls) ActionUnion
//     ActionUnionMessageNew(Message SAActionMessage) ActionUnion
//     ActionUnionRedirectNew(Redirect SARedirectKey) ActionUnion
//     ActionUnionDevbtnNew(Devbtn SADeviceBtn) ActionUnion
//     ActionUnionLockdevbtnNew(Lockdevbtn SALockDeviceBtn) ActionUnion
//     ActionUnionDevvalNew(Devval SADeviceValuator) ActionUnion
//     ActionUnionTypeNew(Type byte) ActionUnion
type ActionUnion struct {
	Noaction     SANoAction
	Setmods      SASetMods
	Latchmods    SALatchMods
	Lockmods     SALockMods
	Setgroup     SASetGroup
	Latchgroup   SALatchGroup
	Lockgroup    SALockGroup
	Moveptr      SAMovePtr
	Ptrbtn       SAPtrBtn
	Lockptrbtn   SALockPtrBtn
	Setptrdflt   SASetPtrDflt
	Isolock      SAIsoLock
	Terminate    SATerminate
	Switchscreen SASwitchScreen
	Setcontrols  SASetControls
	Lockcontrols SALockControls
	Message      SAActionMessage
	Redirect     SARedirectKey
	Devbtn       SADeviceBtn
	Lockdevbtn   SALockDeviceBtn
	Devval       SADeviceValuator
	Type         byte
}

// ActionUnionNoactionNew constructs a new ActionUnion union type with the Noaction field.
func ActionUnionNoactionNew(Noaction SANoAction) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Noaction.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionSetmodsNew constructs a new ActionUnion union type with the Setmods field.
func ActionUnionSetmodsNew(Setmods SASetMods) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Setmods.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionLatchmodsNew constructs a new ActionUnion union type with the Latchmods field.
func ActionUnionLatchmodsNew(Latchmods SALatchMods) ActionUnion {
	var b int
	buf := make([]byte, 8)

	xgb.Put64(buf[b:], uint64(Latchmods))
	b += 8

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionLockmodsNew constructs a new ActionUnion union type with the Lockmods field.
func ActionUnionLockmodsNew(Lockmods SALockMods) ActionUnion {
	var b int
	buf := make([]byte, 8)

	xgb.Put64(buf[b:], uint64(Lockmods))
	b += 8

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionSetgroupNew constructs a new ActionUnion union type with the Setgroup field.
func ActionUnionSetgroupNew(Setgroup SASetGroup) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Setgroup.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionLatchgroupNew constructs a new ActionUnion union type with the Latchgroup field.
func ActionUnionLatchgroupNew(Latchgroup SALatchGroup) ActionUnion {
	var b int
	buf := make([]byte, 8)

	xgb.Put64(buf[b:], uint64(Latchgroup))
	b += 8

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionLockgroupNew constructs a new ActionUnion union type with the Lockgroup field.
func ActionUnionLockgroupNew(Lockgroup SALockGroup) ActionUnion {
	var b int
	buf := make([]byte, 8)

	xgb.Put64(buf[b:], uint64(Lockgroup))
	b += 8

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionMoveptrNew constructs a new ActionUnion union type with the Moveptr field.
func ActionUnionMoveptrNew(Moveptr SAMovePtr) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Moveptr.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionPtrbtnNew constructs a new ActionUnion union type with the Ptrbtn field.
func ActionUnionPtrbtnNew(Ptrbtn SAPtrBtn) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Ptrbtn.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionLockptrbtnNew constructs a new ActionUnion union type with the Lockptrbtn field.
func ActionUnionLockptrbtnNew(Lockptrbtn SALockPtrBtn) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Lockptrbtn.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionSetptrdfltNew constructs a new ActionUnion union type with the Setptrdflt field.
func ActionUnionSetptrdfltNew(Setptrdflt SASetPtrDflt) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Setptrdflt.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionIsolockNew constructs a new ActionUnion union type with the Isolock field.
func ActionUnionIsolockNew(Isolock SAIsoLock) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Isolock.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionTerminateNew constructs a new ActionUnion union type with the Terminate field.
func ActionUnionTerminateNew(Terminate SATerminate) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Terminate.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionSwitchscreenNew constructs a new ActionUnion union type with the Switchscreen field.
func ActionUnionSwitchscreenNew(Switchscreen SASwitchScreen) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Switchscreen.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionSetcontrolsNew constructs a new ActionUnion union type with the Setcontrols field.
func ActionUnionSetcontrolsNew(Setcontrols SASetControls) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Setcontrols.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionLockcontrolsNew constructs a new ActionUnion union type with the Lockcontrols field.
func ActionUnionLockcontrolsNew(Lockcontrols SALockControls) ActionUnion {
	var b int
	buf := make([]byte, 8)

	xgb.Put64(buf[b:], uint64(Lockcontrols))
	b += 8

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionMessageNew constructs a new ActionUnion union type with the Message field.
func ActionUnionMessageNew(Message SAActionMessage) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Message.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionRedirectNew constructs a new ActionUnion union type with the Redirect field.
func ActionUnionRedirectNew(Redirect SARedirectKey) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Redirect.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionDevbtnNew constructs a new ActionUnion union type with the Devbtn field.
func ActionUnionDevbtnNew(Devbtn SADeviceBtn) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Devbtn.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionLockdevbtnNew constructs a new ActionUnion union type with the Lockdevbtn field.
func ActionUnionLockdevbtnNew(Lockdevbtn SALockDeviceBtn) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Lockdevbtn.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionDevvalNew constructs a new ActionUnion union type with the Devval field.
func ActionUnionDevvalNew(Devval SADeviceValuator) ActionUnion {
	var b int
	buf := make([]byte, 8)

	{
		structBytes := Devval.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionTypeNew constructs a new ActionUnion union type with the Type field.
func ActionUnionTypeNew(Type byte) ActionUnion {
	var b int
	buf := make([]byte, 8)

	buf[b] = Type
	b += 1

	// Create the Union type
	v := ActionUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // always read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // always read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // always read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // always read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // always read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // always read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // always read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // always read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // always read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // always read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // always read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // always read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // always read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // always read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // always read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // always read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// ActionUnionRead reads a byte slice into a ActionUnion value.
func ActionUnionRead(buf []byte, v *ActionUnion) int {
	var b int

	b = 0 // re-read the same bytes
	v.Noaction = SANoAction{}
	b += SANoActionRead(buf[b:], &v.Noaction)

	b = 0 // re-read the same bytes
	v.Setmods = SASetMods{}
	b += SASetModsRead(buf[b:], &v.Setmods)

	b = 0 // re-read the same bytes
	v.Latchmods = SALatchMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // re-read the same bytes
	v.Lockmods = SALockMods(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // re-read the same bytes
	v.Setgroup = SASetGroup{}
	b += SASetGroupRead(buf[b:], &v.Setgroup)

	b = 0 // re-read the same bytes
	v.Latchgroup = SALatchGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // re-read the same bytes
	v.Lockgroup = SALockGroup(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // re-read the same bytes
	v.Moveptr = SAMovePtr{}
	b += SAMovePtrRead(buf[b:], &v.Moveptr)

	b = 0 // re-read the same bytes
	v.Ptrbtn = SAPtrBtn{}
	b += SAPtrBtnRead(buf[b:], &v.Ptrbtn)

	b = 0 // re-read the same bytes
	v.Lockptrbtn = SALockPtrBtn{}
	b += SALockPtrBtnRead(buf[b:], &v.Lockptrbtn)

	b = 0 // re-read the same bytes
	v.Setptrdflt = SASetPtrDflt{}
	b += SASetPtrDfltRead(buf[b:], &v.Setptrdflt)

	b = 0 // re-read the same bytes
	v.Isolock = SAIsoLock{}
	b += SAIsoLockRead(buf[b:], &v.Isolock)

	b = 0 // re-read the same bytes
	v.Terminate = SATerminate{}
	b += SATerminateRead(buf[b:], &v.Terminate)

	b = 0 // re-read the same bytes
	v.Switchscreen = SASwitchScreen{}
	b += SASwitchScreenRead(buf[b:], &v.Switchscreen)

	b = 0 // re-read the same bytes
	v.Setcontrols = SASetControls{}
	b += SASetControlsRead(buf[b:], &v.Setcontrols)

	b = 0 // re-read the same bytes
	v.Lockcontrols = SALockControls(xgb.Get64(buf[b:]))
	b += 8

	b = 0 // re-read the same bytes
	v.Message = SAActionMessage{}
	b += SAActionMessageRead(buf[b:], &v.Message)

	b = 0 // re-read the same bytes
	v.Redirect = SARedirectKey{}
	b += SARedirectKeyRead(buf[b:], &v.Redirect)

	b = 0 // re-read the same bytes
	v.Devbtn = SADeviceBtn{}
	b += SADeviceBtnRead(buf[b:], &v.Devbtn)

	b = 0 // re-read the same bytes
	v.Lockdevbtn = SALockDeviceBtn{}
	b += SALockDeviceBtnRead(buf[b:], &v.Lockdevbtn)

	b = 0 // re-read the same bytes
	v.Devval = SADeviceValuator{}
	b += SADeviceValuatorRead(buf[b:], &v.Devval)

	b = 0 // re-read the same bytes
	v.Type = buf[b]
	b += 1

	return 8
}

// ActionUnionReadList reads a byte slice into a list of ActionUnion values.
func ActionUnionReadList(buf []byte, dest []ActionUnion) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ActionUnion{}
		b += ActionUnionRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a ActionUnion value to a byte slice.
// Each field in a union must contain the same data.
// So simply pick the first field and write that to the wire.
func (v ActionUnion) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	{
		structBytes := v.Noaction.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return buf
}

// ActionUnionListBytes writes a list of ActionUnion values to a byte slice.
func ActionUnionListBytes(buf []byte, list []ActionUnion) int {
	b := 0
	var unionBytes []byte
	for _, item := range list {
		unionBytes = item.Bytes()
		copy(buf[b:], unionBytes)
		b += xgb.Pad(len(unionBytes))
	}
	return b
}

const (
	BehaviorTypeDefault             = 0
	BehaviorTypeLock                = 1
	BehaviorTypeRadioGroup          = 2
	BehaviorTypeOverlay1            = 3
	BehaviorTypeOverlay2            = 4
	BehaviorTypePermamentLock       = 129
	BehaviorTypePermamentRadioGroup = 130
	BehaviorTypePermamentOverlay1   = 131
	BehaviorTypePermamentOverlay2   = 132
)

// BehaviorUnion is a represention of the BehaviorUnion union type.
// Note that to *create* a Union, you should *never* create
// this struct directly (unless you know what you're doing).
// Instead use one of the following constructors for 'BehaviorUnion':
//     BehaviorUnionCommonNew(Common CommonBehavior) BehaviorUnion
//     BehaviorUnionDefaultNew(Default DefaultBehavior) BehaviorUnion
//     BehaviorUnionLockNew(Lock LockBehavior) BehaviorUnion
//     BehaviorUnionRadioGroupNew(RadioGroup RadioGroupBehavior) BehaviorUnion
//     BehaviorUnionOverlay1New(Overlay1 OverlayBehavior) BehaviorUnion
//     BehaviorUnionOverlay2New(Overlay2 OverlayBehavior) BehaviorUnion
//     BehaviorUnionPermamentLockNew(PermamentLock PermamentLockBehavior) BehaviorUnion
//     BehaviorUnionPermamentRadioGroupNew(PermamentRadioGroup PermamentRadioGroupBehavior) BehaviorUnion
//     BehaviorUnionPermamentOverlay1New(PermamentOverlay1 PermamentOverlayBehavior) BehaviorUnion
//     BehaviorUnionPermamentOverlay2New(PermamentOverlay2 PermamentOverlayBehavior) BehaviorUnion
//     BehaviorUnionTypeNew(Type byte) BehaviorUnion
type BehaviorUnion struct {
	Common              CommonBehavior
	Default             DefaultBehavior
	Lock                LockBehavior
	RadioGroup          RadioGroupBehavior
	Overlay1            OverlayBehavior
	Overlay2            OverlayBehavior
	PermamentLock       PermamentLockBehavior
	PermamentRadioGroup PermamentRadioGroupBehavior
	PermamentOverlay1   PermamentOverlayBehavior
	PermamentOverlay2   PermamentOverlayBehavior
	Type                byte
}

// BehaviorUnionCommonNew constructs a new BehaviorUnion union type with the Common field.
func BehaviorUnionCommonNew(Common CommonBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	{
		structBytes := Common.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionDefaultNew constructs a new BehaviorUnion union type with the Default field.
func BehaviorUnionDefaultNew(Default DefaultBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	{
		structBytes := Default.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionLockNew constructs a new BehaviorUnion union type with the Lock field.
func BehaviorUnionLockNew(Lock LockBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	xgb.Put16(buf[b:], uint16(Lock))
	b += 2

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionRadioGroupNew constructs a new BehaviorUnion union type with the RadioGroup field.
func BehaviorUnionRadioGroupNew(RadioGroup RadioGroupBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	{
		structBytes := RadioGroup.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionOverlay1New constructs a new BehaviorUnion union type with the Overlay1 field.
func BehaviorUnionOverlay1New(Overlay1 OverlayBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	{
		structBytes := Overlay1.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionOverlay2New constructs a new BehaviorUnion union type with the Overlay2 field.
func BehaviorUnionOverlay2New(Overlay2 OverlayBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	{
		structBytes := Overlay2.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionPermamentLockNew constructs a new BehaviorUnion union type with the PermamentLock field.
func BehaviorUnionPermamentLockNew(PermamentLock PermamentLockBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	xgb.Put16(buf[b:], uint16(PermamentLock))
	b += 2

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionPermamentRadioGroupNew constructs a new BehaviorUnion union type with the PermamentRadioGroup field.
func BehaviorUnionPermamentRadioGroupNew(PermamentRadioGroup PermamentRadioGroupBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	xgb.Put16(buf[b:], uint16(PermamentRadioGroup))
	b += 2

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionPermamentOverlay1New constructs a new BehaviorUnion union type with the PermamentOverlay1 field.
func BehaviorUnionPermamentOverlay1New(PermamentOverlay1 PermamentOverlayBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	xgb.Put16(buf[b:], uint16(PermamentOverlay1))
	b += 2

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionPermamentOverlay2New constructs a new BehaviorUnion union type with the PermamentOverlay2 field.
func BehaviorUnionPermamentOverlay2New(PermamentOverlay2 PermamentOverlayBehavior) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	xgb.Put16(buf[b:], uint16(PermamentOverlay2))
	b += 2

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionTypeNew constructs a new BehaviorUnion union type with the Type field.
func BehaviorUnionTypeNew(Type byte) BehaviorUnion {
	var b int
	buf := make([]byte, 2)

	buf[b] = Type
	b += 1

	// Create the Union type
	v := BehaviorUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // always read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // always read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // always read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // always read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // always read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // always read the same bytes
	v.Type = buf[b]
	b += 1

	return v
}

// BehaviorUnionRead reads a byte slice into a BehaviorUnion value.
func BehaviorUnionRead(buf []byte, v *BehaviorUnion) int {
	var b int

	b = 0 // re-read the same bytes
	v.Common = CommonBehavior{}
	b += CommonBehaviorRead(buf[b:], &v.Common)

	b = 0 // re-read the same bytes
	v.Default = DefaultBehavior{}
	b += DefaultBehaviorRead(buf[b:], &v.Default)

	b = 0 // re-read the same bytes
	v.Lock = LockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // re-read the same bytes
	v.RadioGroup = RadioGroupBehavior{}
	b += RadioGroupBehaviorRead(buf[b:], &v.RadioGroup)

	b = 0 // re-read the same bytes
	v.Overlay1 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay1)

	b = 0 // re-read the same bytes
	v.Overlay2 = OverlayBehavior{}
	b += OverlayBehaviorRead(buf[b:], &v.Overlay2)

	b = 0 // re-read the same bytes
	v.PermamentLock = PermamentLockBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // re-read the same bytes
	v.PermamentRadioGroup = PermamentRadioGroupBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // re-read the same bytes
	v.PermamentOverlay1 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // re-read the same bytes
	v.PermamentOverlay2 = PermamentOverlayBehavior(xgb.Get16(buf[b:]))
	b += 2

	b = 0 // re-read the same bytes
	v.Type = buf[b]
	b += 1

	return 2
}

// BehaviorUnionReadList reads a byte slice into a list of BehaviorUnion values.
func BehaviorUnionReadList(buf []byte, dest []BehaviorUnion) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = BehaviorUnion{}
		b += BehaviorUnionRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a BehaviorUnion value to a byte slice.
// Each field in a union must contain the same data.
// So simply pick the first field and write that to the wire.
func (v BehaviorUnion) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	{
		structBytes := v.Common.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return buf
}

// BehaviorUnionListBytes writes a list of BehaviorUnion values to a byte slice.
func BehaviorUnionListBytes(buf []byte, list []BehaviorUnion) int {
	b := 0
	var unionBytes []byte
	for _, item := range list {
		unionBytes = item.Bytes()
		copy(buf[b:], unionBytes)
		b += xgb.Pad(len(unionBytes))
	}
	return b
}

const (
	BellClassKbdFeedbackClass  = 0
	BellClassBellFeedbackClass = 5
	BellClassDfltXIClass       = 768
)

const (
	BellClassResultKbdFeedbackClass  = 0
	BellClassResultBellFeedbackClass = 5
)

type BellClassSpec uint16

// BellNotify is the event number for a BellNotifyEvent.
const BellNotify = 8

type BellNotifyEvent struct {
	Sequence  uint16
	XkbType   byte
	Time      xproto.Timestamp
	DeviceID  byte
	BellClass byte
	BellID    byte
	Percent   byte
	Pitch     uint16
	Duration  uint16
	Name      xproto.Atom
	Window    xproto.Window
	EventOnly bool
	// padding: 7 bytes
}

// BellNotifyEventNew constructs a BellNotifyEvent value that implements xgb.Event from a byte slice.
func BellNotifyEventNew(buf []byte) xgb.Event {
	v := BellNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	v.BellClass = buf[b]
	b += 1

	v.BellID = buf[b]
	b += 1

	v.Percent = buf[b]
	b += 1

	v.Pitch = xgb.Get16(buf[b:])
	b += 2

	v.Duration = xgb.Get16(buf[b:])
	b += 2

	v.Name = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Window = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	if buf[b] == 1 {
		v.EventOnly = true
	} else {
		v.EventOnly = false
	}
	b += 1

	b += 7 // padding

	return v
}

// Bytes writes a BellNotifyEvent value to a byte slice.
func (v BellNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 8
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	buf[b] = v.BellClass
	b += 1

	buf[b] = v.BellID
	b += 1

	buf[b] = v.Percent
	b += 1

	xgb.Put16(buf[b:], v.Pitch)
	b += 2

	xgb.Put16(buf[b:], v.Duration)
	b += 2

	xgb.Put32(buf[b:], uint32(v.Name))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	if v.EventOnly {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 7 // padding

	return buf
}

// SequenceId returns the sequence id attached to the BellNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v BellNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of BellNotifyEvent.
func (v BellNotifyEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("BellClass: %d", v.BellClass))
	fieldVals = append(fieldVals, xgb.Sprintf("BellID: %d", v.BellID))
	fieldVals = append(fieldVals, xgb.Sprintf("Percent: %d", v.Percent))
	fieldVals = append(fieldVals, xgb.Sprintf("Pitch: %d", v.Pitch))
	fieldVals = append(fieldVals, xgb.Sprintf("Duration: %d", v.Duration))
	fieldVals = append(fieldVals, xgb.Sprintf("Name: %d", v.Name))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("EventOnly: %t", v.EventOnly))
	return "BellNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][8] = BellNotifyEventNew
}

const (
	BoolCtrlRepeatKeys          = 1
	BoolCtrlSlowKeys            = 2
	BoolCtrlBounceKeys          = 4
	BoolCtrlStickyKeys          = 8
	BoolCtrlMouseKeys           = 16
	BoolCtrlMouseKeysAccel      = 32
	BoolCtrlAccessXKeys         = 64
	BoolCtrlAccessXTimeoutMask  = 128
	BoolCtrlAccessXFeedbackMask = 256
	BoolCtrlAudibleBellMask     = 512
	BoolCtrlOverlay1Mask        = 1024
	BoolCtrlOverlay2Mask        = 2048
	BoolCtrlIgnoreGroupLockMask = 4096
)

const (
	BoolCtrlsHighAccessXFeedback = 1
	BoolCtrlsHighAudibleBell     = 2
	BoolCtrlsHighOverlay1        = 4
	BoolCtrlsHighOverlay2        = 8
	BoolCtrlsHighIgnoreGroupLock = 16
)

const (
	BoolCtrlsLowRepeatKeys     = 1
	BoolCtrlsLowSlowKeys       = 2
	BoolCtrlsLowBounceKeys     = 4
	BoolCtrlsLowStickyKeys     = 8
	BoolCtrlsLowMouseKeys      = 16
	BoolCtrlsLowMouseKeysAccel = 32
	BoolCtrlsLowAccessXKeys    = 64
	BoolCtrlsLowAccessXTimeout = 128
)

const (
	CMDetailSymInterp   = 1
	CMDetailGroupCompat = 2
)

type CommonBehavior struct {
	Type byte
	Data byte
}

// CommonBehaviorRead reads a byte slice into a CommonBehavior value.
func CommonBehaviorRead(buf []byte, v *CommonBehavior) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Data = buf[b]
	b += 1

	return b
}

// CommonBehaviorReadList reads a byte slice into a list of CommonBehavior values.
func CommonBehaviorReadList(buf []byte, dest []CommonBehavior) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = CommonBehavior{}
		b += CommonBehaviorRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a CommonBehavior value to a byte slice.
func (v CommonBehavior) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Data
	b += 1

	return buf[:b]
}

// CommonBehaviorListBytes writes a list of CommonBehavior values to a byte slice.
func CommonBehaviorListBytes(buf []byte, list []CommonBehavior) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// CompatMapNotify is the event number for a CompatMapNotifyEvent.
const CompatMapNotify = 7

type CompatMapNotifyEvent struct {
	Sequence      uint16
	XkbType       byte
	Time          xproto.Timestamp
	DeviceID      byte
	ChangedGroups byte
	FirstSI       uint16
	NSI           uint16
	NTotalSI      uint16
	// padding: 16 bytes
}

// CompatMapNotifyEventNew constructs a CompatMapNotifyEvent value that implements xgb.Event from a byte slice.
func CompatMapNotifyEventNew(buf []byte) xgb.Event {
	v := CompatMapNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	v.ChangedGroups = buf[b]
	b += 1

	v.FirstSI = xgb.Get16(buf[b:])
	b += 2

	v.NSI = xgb.Get16(buf[b:])
	b += 2

	v.NTotalSI = xgb.Get16(buf[b:])
	b += 2

	b += 16 // padding

	return v
}

// Bytes writes a CompatMapNotifyEvent value to a byte slice.
func (v CompatMapNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 7
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	buf[b] = v.ChangedGroups
	b += 1

	xgb.Put16(buf[b:], v.FirstSI)
	b += 2

	xgb.Put16(buf[b:], v.NSI)
	b += 2

	xgb.Put16(buf[b:], v.NTotalSI)
	b += 2

	b += 16 // padding

	return buf
}

// SequenceId returns the sequence id attached to the CompatMapNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v CompatMapNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of CompatMapNotifyEvent.
func (v CompatMapNotifyEvent) String() string {
	fieldVals := make([]string, 0, 8)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("ChangedGroups: %d", v.ChangedGroups))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstSI: %d", v.FirstSI))
	fieldVals = append(fieldVals, xgb.Sprintf("NSI: %d", v.NSI))
	fieldVals = append(fieldVals, xgb.Sprintf("NTotalSI: %d", v.NTotalSI))
	return "CompatMapNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][7] = CompatMapNotifyEventNew
}

const (
	ConstMaxLegalKeyCode    = 255
	ConstPerKeyBitArraySize = 32
	ConstKeyNameLength      = 4
)

const (
	ControlGroupsWrap      = 134217728
	ControlInternalMods    = 268435456
	ControlIgnoreLockMods  = 536870912
	ControlPerKeyRepeat    = 1073741824
	ControlControlsEnabled = 2147483648
)

// ControlsNotify is the event number for a ControlsNotifyEvent.
const ControlsNotify = 3

type ControlsNotifyEvent struct {
	Sequence  uint16
	XkbType   byte
	Time      xproto.Timestamp
	DeviceID  byte
	NumGroups byte
	// padding: 2 bytes
	ChangedControls       uint32
	EnabledControls       uint32
	EnabledControlChanges uint32
	Keycode               xproto.Keycode
	EventType             byte
	RequestMajor          byte
	RequestMinor          byte
	// padding: 4 bytes
}

// ControlsNotifyEventNew constructs a ControlsNotifyEvent value that implements xgb.Event from a byte slice.
func ControlsNotifyEventNew(buf []byte) xgb.Event {
	v := ControlsNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	v.NumGroups = buf[b]
	b += 1

	b += 2 // padding

	v.ChangedControls = xgb.Get32(buf[b:])
	b += 4

	v.EnabledControls = xgb.Get32(buf[b:])
	b += 4

	v.EnabledControlChanges = xgb.Get32(buf[b:])
	b += 4

	v.Keycode = xproto.Keycode(buf[b])
	b += 1

	v.EventType = buf[b]
	b += 1

	v.RequestMajor = buf[b]
	b += 1

	v.RequestMinor = buf[b]
	b += 1

	b += 4 // padding

	return v
}

// Bytes writes a ControlsNotifyEvent value to a byte slice.
func (v ControlsNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 3
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	buf[b] = v.NumGroups
	b += 1

	b += 2 // padding

	xgb.Put32(buf[b:], v.ChangedControls)
	b += 4

	xgb.Put32(buf[b:], v.EnabledControls)
	b += 4

	xgb.Put32(buf[b:], v.EnabledControlChanges)
	b += 4

	buf[b] = byte(v.Keycode)
	b += 1

	buf[b] = v.EventType
	b += 1

	buf[b] = v.RequestMajor
	b += 1

	buf[b] = v.RequestMinor
	b += 1

	b += 4 // padding

	return buf
}

// SequenceId returns the sequence id attached to the ControlsNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v ControlsNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of ControlsNotifyEvent.
func (v ControlsNotifyEvent) String() string {
	fieldVals := make([]string, 0, 13)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("NumGroups: %d", v.NumGroups))
	fieldVals = append(fieldVals, xgb.Sprintf("ChangedControls: %d", v.ChangedControls))
	fieldVals = append(fieldVals, xgb.Sprintf("EnabledControls: %d", v.EnabledControls))
	fieldVals = append(fieldVals, xgb.Sprintf("EnabledControlChanges: %d", v.EnabledControlChanges))
	fieldVals = append(fieldVals, xgb.Sprintf("Keycode: %d", v.Keycode))
	fieldVals = append(fieldVals, xgb.Sprintf("EventType: %d", v.EventType))
	fieldVals = append(fieldVals, xgb.Sprintf("RequestMajor: %d", v.RequestMajor))
	fieldVals = append(fieldVals, xgb.Sprintf("RequestMinor: %d", v.RequestMinor))
	return "ControlsNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][3] = ControlsNotifyEventNew
}

type CountedString16 struct {
	Length       uint16
	String       string // size: xgb.Pad((int(Length) * 1))
	AlignmentPad []byte // size: xgb.Pad(((((int(Length) + 5) & -4) - (int(Length) + 2)) * 1))
}

// CountedString16Read reads a byte slice into a CountedString16 value.
func CountedString16Read(buf []byte, v *CountedString16) int {
	b := 0

	v.Length = xgb.Get16(buf[b:])
	b += 2

	{
		byteString := make([]byte, v.Length)
		copy(byteString[:v.Length], buf[b:])
		v.String = string(byteString)
		b += int(v.Length)
	}

	v.AlignmentPad = make([]byte, (((int(v.Length) + 5) & -4) - (int(v.Length) + 2)))
	copy(v.AlignmentPad[:(((int(v.Length)+5)&-4)-(int(v.Length)+2))], buf[b:])
	b += int((((int(v.Length) + 5) & -4) - (int(v.Length) + 2)))

	return b
}

// CountedString16ReadList reads a byte slice into a list of CountedString16 values.
func CountedString16ReadList(buf []byte, dest []CountedString16) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = CountedString16{}
		b += CountedString16Read(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a CountedString16 value to a byte slice.
func (v CountedString16) Bytes() []byte {
	buf := make([]byte, ((2 + xgb.Pad((int(v.Length) * 1))) + xgb.Pad(((((int(v.Length) + 5) & -4) - (int(v.Length) + 2)) * 1))))
	b := 0

	xgb.Put16(buf[b:], v.Length)
	b += 2

	copy(buf[b:], v.String[:v.Length])
	b += int(v.Length)

	copy(buf[b:], v.AlignmentPad[:(((int(v.Length)+5)&-4)-(int(v.Length)+2))])
	b += int((((int(v.Length) + 5) & -4) - (int(v.Length) + 2)))

	return buf[:b]
}

// CountedString16ListBytes writes a list of CountedString16 values to a byte slice.
func CountedString16ListBytes(buf []byte, list []CountedString16) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// CountedString16ListSize computes the size (bytes) of a list of CountedString16 values.
func CountedString16ListSize(list []CountedString16) int {
	size := 0
	for _, item := range list {
		size += ((2 + xgb.Pad((int(item.Length) * 1))) + xgb.Pad(((((int(item.Length) + 5) & -4) - (int(item.Length) + 2)) * 1)))
	}
	return size
}

type DefaultBehavior struct {
	Type byte
	// padding: 1 bytes
}

// DefaultBehaviorRead reads a byte slice into a DefaultBehavior value.
func DefaultBehaviorRead(buf []byte, v *DefaultBehavior) int {
	b := 0

	v.Type = buf[b]
	b += 1

	b += 1 // padding

	return b
}

// DefaultBehaviorReadList reads a byte slice into a list of DefaultBehavior values.
func DefaultBehaviorReadList(buf []byte, dest []DefaultBehavior) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DefaultBehavior{}
		b += DefaultBehaviorRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DefaultBehavior value to a byte slice.
func (v DefaultBehavior) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.Type
	b += 1

	b += 1 // padding

	return buf[:b]
}

// DefaultBehaviorListBytes writes a list of DefaultBehavior values to a byte slice.
func DefaultBehaviorListBytes(buf []byte, list []DefaultBehavior) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type DeviceLedInfo struct {
	LedClass       LedClassSpec
	LedID          IDSpec
	NamesPresent   uint32
	MapsPresent    uint32
	PhysIndicators uint32
	State          uint32
	Names          []xproto.Atom  // size: xgb.Pad((xgb.PopCount(NamesPresent) * 4))
	Maps           []IndicatorMap // size: xgb.Pad((xgb.PopCount(MapsPresent) * 12))
}

// DeviceLedInfoRead reads a byte slice into a DeviceLedInfo value.
func DeviceLedInfoRead(buf []byte, v *DeviceLedInfo) int {
	b := 0

	v.LedClass = LedClassSpec(xgb.Get16(buf[b:]))
	b += 2

	v.LedID = IDSpec(xgb.Get16(buf[b:]))
	b += 2

	v.NamesPresent = xgb.Get32(buf[b:])
	b += 4

	v.MapsPresent = xgb.Get32(buf[b:])
	b += 4

	v.PhysIndicators = xgb.Get32(buf[b:])
	b += 4

	v.State = xgb.Get32(buf[b:])
	b += 4

	v.Names = make([]xproto.Atom, xgb.PopCount(v.NamesPresent))
	for i := 0; i < int(xgb.PopCount(v.NamesPresent)); i++ {
		v.Names[i] = xproto.Atom(xgb.Get32(buf[b:]))
		b += 4
	}

	v.Maps = make([]IndicatorMap, xgb.PopCount(v.MapsPresent))
	b += IndicatorMapReadList(buf[b:], v.Maps)

	return b
}

// DeviceLedInfoReadList reads a byte slice into a list of DeviceLedInfo values.
func DeviceLedInfoReadList(buf []byte, dest []DeviceLedInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceLedInfo{}
		b += DeviceLedInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceLedInfo value to a byte slice.
func (v DeviceLedInfo) Bytes() []byte {
	buf := make([]byte, ((20 + xgb.Pad((xgb.PopCount(v.NamesPresent) * 4))) + xgb.Pad((xgb.PopCount(v.MapsPresent) * 12))))
	b := 0

	xgb.Put16(buf[b:], uint16(v.LedClass))
	b += 2

	xgb.Put16(buf[b:], uint16(v.LedID))
	b += 2

	xgb.Put32(buf[b:], v.NamesPresent)
	b += 4

	xgb.Put32(buf[b:], v.MapsPresent)
	b += 4

	xgb.Put32(buf[b:], v.PhysIndicators)
	b += 4

	xgb.Put32(buf[b:], v.State)
	b += 4

	for i := 0; i < int(xgb.PopCount(v.NamesPresent)); i++ {
		xgb.Put32(buf[b:], uint32(v.Names[i]))
		b += 4
	}

	b += IndicatorMapListBytes(buf[b:], v.Maps)

	return buf[:b]
}

// DeviceLedInfoListBytes writes a list of DeviceLedInfo values to a byte slice.
func DeviceLedInfoListBytes(buf []byte, list []DeviceLedInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// DeviceLedInfoListSize computes the size (bytes) of a list of DeviceLedInfo values.
func DeviceLedInfoListSize(list []DeviceLedInfo) int {
	size := 0
	for _, item := range list {
		size += ((20 + xgb.Pad((xgb.PopCount(item.NamesPresent) * 4))) + xgb.Pad((xgb.PopCount(item.MapsPresent) * 12)))
	}
	return size
}

type DeviceSpec uint16

const (
	DoodadTypeOutline   = 1
	DoodadTypeSolid     = 2
	DoodadTypeText      = 3
	DoodadTypeIndicator = 4
	DoodadTypeLogo      = 5
)

const (
	ErrorBadDevice = 255
	ErrorBadClass  = 254
	ErrorBadId     = 253
)

const (
	EventTypeNewKeyboardNotify     = 1
	EventTypeMapNotify             = 2
	EventTypeStateNotify           = 4
	EventTypeControlsNotify        = 8
	EventTypeIndicatorStateNotify  = 16
	EventTypeIndicatorMapNotify    = 32
	EventTypeNamesNotify           = 64
	EventTypeCompatMapNotify       = 128
	EventTypeBellNotify            = 256
	EventTypeActionMessage         = 512
	EventTypeAccessXNotify         = 1024
	EventTypeExtensionDeviceNotify = 2048
)

const (
	ExplicitVModMap    = 128
	ExplicitBehavior   = 64
	ExplicitAutoRepeat = 32
	ExplicitInterpret  = 16
	ExplicitKeyType4   = 8
	ExplicitKeyType3   = 4
	ExplicitKeyType2   = 2
	ExplicitKeyType1   = 1
)

// ExtensionDeviceNotify is the event number for a ExtensionDeviceNotifyEvent.
const ExtensionDeviceNotify = 11

type ExtensionDeviceNotifyEvent struct {
	Sequence uint16
	XkbType  byte
	Time     xproto.Timestamp
	DeviceID byte
	// padding: 1 bytes
	Reason      uint16
	LedClass    uint16
	LedID       uint16
	LedsDefined uint32
	LedState    uint32
	FirstButton byte
	NButtons    byte
	Supported   uint16
	Unsupported uint16
	// padding: 2 bytes
}

// ExtensionDeviceNotifyEventNew constructs a ExtensionDeviceNotifyEvent value that implements xgb.Event from a byte slice.
func ExtensionDeviceNotifyEventNew(buf []byte) xgb.Event {
	v := ExtensionDeviceNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	b += 1 // padding

	v.Reason = xgb.Get16(buf[b:])
	b += 2

	v.LedClass = xgb.Get16(buf[b:])
	b += 2

	v.LedID = xgb.Get16(buf[b:])
	b += 2

	v.LedsDefined = xgb.Get32(buf[b:])
	b += 4

	v.LedState = xgb.Get32(buf[b:])
	b += 4

	v.FirstButton = buf[b]
	b += 1

	v.NButtons = buf[b]
	b += 1

	v.Supported = xgb.Get16(buf[b:])
	b += 2

	v.Unsupported = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return v
}

// Bytes writes a ExtensionDeviceNotifyEvent value to a byte slice.
func (v ExtensionDeviceNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 11
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], v.Reason)
	b += 2

	xgb.Put16(buf[b:], v.LedClass)
	b += 2

	xgb.Put16(buf[b:], v.LedID)
	b += 2

	xgb.Put32(buf[b:], v.LedsDefined)
	b += 4

	xgb.Put32(buf[b:], v.LedState)
	b += 4

	buf[b] = v.FirstButton
	b += 1

	buf[b] = v.NButtons
	b += 1

	xgb.Put16(buf[b:], v.Supported)
	b += 2

	xgb.Put16(buf[b:], v.Unsupported)
	b += 2

	b += 2 // padding

	return buf
}

// SequenceId returns the sequence id attached to the ExtensionDeviceNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v ExtensionDeviceNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of ExtensionDeviceNotifyEvent.
func (v ExtensionDeviceNotifyEvent) String() string {
	fieldVals := make([]string, 0, 14)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("Reason: %d", v.Reason))
	fieldVals = append(fieldVals, xgb.Sprintf("LedClass: %d", v.LedClass))
	fieldVals = append(fieldVals, xgb.Sprintf("LedID: %d", v.LedID))
	fieldVals = append(fieldVals, xgb.Sprintf("LedsDefined: %d", v.LedsDefined))
	fieldVals = append(fieldVals, xgb.Sprintf("LedState: %d", v.LedState))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstButton: %d", v.FirstButton))
	fieldVals = append(fieldVals, xgb.Sprintf("NButtons: %d", v.NButtons))
	fieldVals = append(fieldVals, xgb.Sprintf("Supported: %d", v.Supported))
	fieldVals = append(fieldVals, xgb.Sprintf("Unsupported: %d", v.Unsupported))
	return "ExtensionDeviceNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][11] = ExtensionDeviceNotifyEventNew
}

const (
	GBNDetailTypes         = 1
	GBNDetailCompatMap     = 2
	GBNDetailClientSymbols = 4
	GBNDetailServerSymbols = 8
	GBNDetailIndicatorMaps = 16
	GBNDetailKeyNames      = 32
	GBNDetailGeometry      = 64
	GBNDetailOtherNames    = 128
)

const (
	Group1 = 0
	Group2 = 1
	Group3 = 2
	Group4 = 3
)

const (
	GroupsAny = 254
	GroupsAll = 255
)

const (
	GroupsWrapWrapIntoRange     = 0
	GroupsWrapClampIntoRange    = 64
	GroupsWrapRedirectIntoRange = 128
)

type IDSpec uint16

const (
	IMFlagNoExplicit  = 128
	IMFlagNoAutomatic = 64
	IMFlagLEDDrivesKB = 32
)

const (
	IMGroupsWhichUseCompat    = 16
	IMGroupsWhichUseEffective = 8
	IMGroupsWhichUseLocked    = 4
	IMGroupsWhichUseLatched   = 2
	IMGroupsWhichUseBase      = 1
)

const (
	IMModsWhichUseCompat    = 16
	IMModsWhichUseEffective = 8
	IMModsWhichUseLocked    = 4
	IMModsWhichUseLatched   = 2
	IMModsWhichUseBase      = 1
)

const (
	IdUseCoreKbd  = 256
	IdUseCorePtr  = 512
	IdDfltXIClass = 768
	IdDfltXIId    = 1024
	IdAllXIClass  = 1280
	IdAllXIId     = 1536
	IdXINone      = 65280
)

type IndicatorMap struct {
	Flags       byte
	WhichGroups byte
	Groups      byte
	WhichMods   byte
	Mods        byte
	RealMods    byte
	Vmods       uint16
	Ctrls       uint32
}

// IndicatorMapRead reads a byte slice into a IndicatorMap value.
func IndicatorMapRead(buf []byte, v *IndicatorMap) int {
	b := 0

	v.Flags = buf[b]
	b += 1

	v.WhichGroups = buf[b]
	b += 1

	v.Groups = buf[b]
	b += 1

	v.WhichMods = buf[b]
	b += 1

	v.Mods = buf[b]
	b += 1

	v.RealMods = buf[b]
	b += 1

	v.Vmods = xgb.Get16(buf[b:])
	b += 2

	v.Ctrls = xgb.Get32(buf[b:])
	b += 4

	return b
}

// IndicatorMapReadList reads a byte slice into a list of IndicatorMap values.
func IndicatorMapReadList(buf []byte, dest []IndicatorMap) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = IndicatorMap{}
		b += IndicatorMapRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a IndicatorMap value to a byte slice.
func (v IndicatorMap) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.Flags
	b += 1

	buf[b] = v.WhichGroups
	b += 1

	buf[b] = v.Groups
	b += 1

	buf[b] = v.WhichMods
	b += 1

	buf[b] = v.Mods
	b += 1

	buf[b] = v.RealMods
	b += 1

	xgb.Put16(buf[b:], v.Vmods)
	b += 2

	xgb.Put32(buf[b:], v.Ctrls)
	b += 4

	return buf[:b]
}

// IndicatorMapListBytes writes a list of IndicatorMap values to a byte slice.
func IndicatorMapListBytes(buf []byte, list []IndicatorMap) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// IndicatorMapNotify is the event number for a IndicatorMapNotifyEvent.
const IndicatorMapNotify = 5

type IndicatorMapNotifyEvent struct {
	Sequence uint16
	XkbType  byte
	Time     xproto.Timestamp
	DeviceID byte
	// padding: 3 bytes
	State      uint32
	MapChanged uint32
	// padding: 12 bytes
}

// IndicatorMapNotifyEventNew constructs a IndicatorMapNotifyEvent value that implements xgb.Event from a byte slice.
func IndicatorMapNotifyEventNew(buf []byte) xgb.Event {
	v := IndicatorMapNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	b += 3 // padding

	v.State = xgb.Get32(buf[b:])
	b += 4

	v.MapChanged = xgb.Get32(buf[b:])
	b += 4

	b += 12 // padding

	return v
}

// Bytes writes a IndicatorMapNotifyEvent value to a byte slice.
func (v IndicatorMapNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 5
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], v.State)
	b += 4

	xgb.Put32(buf[b:], v.MapChanged)
	b += 4

	b += 12 // padding

	return buf
}

// SequenceId returns the sequence id attached to the IndicatorMapNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v IndicatorMapNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of IndicatorMapNotifyEvent.
func (v IndicatorMapNotifyEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("MapChanged: %d", v.MapChanged))
	return "IndicatorMapNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][5] = IndicatorMapNotifyEventNew
}

// IndicatorStateNotify is the event number for a IndicatorStateNotifyEvent.
const IndicatorStateNotify = 4

type IndicatorStateNotifyEvent struct {
	Sequence uint16
	XkbType  byte
	Time     xproto.Timestamp
	DeviceID byte
	// padding: 3 bytes
	State        uint32
	StateChanged uint32
	// padding: 12 bytes
}

// IndicatorStateNotifyEventNew constructs a IndicatorStateNotifyEvent value that implements xgb.Event from a byte slice.
func IndicatorStateNotifyEventNew(buf []byte) xgb.Event {
	v := IndicatorStateNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	b += 3 // padding

	v.State = xgb.Get32(buf[b:])
	b += 4

	v.StateChanged = xgb.Get32(buf[b:])
	b += 4

	b += 12 // padding

	return v
}

// Bytes writes a IndicatorStateNotifyEvent value to a byte slice.
func (v IndicatorStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 4
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], v.State)
	b += 4

	xgb.Put32(buf[b:], v.StateChanged)
	b += 4

	b += 12 // padding

	return buf
}

// SequenceId returns the sequence id attached to the IndicatorStateNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v IndicatorStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of IndicatorStateNotifyEvent.
func (v IndicatorStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("StateChanged: %d", v.StateChanged))
	return "IndicatorStateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][4] = IndicatorStateNotifyEventNew
}

type KTMapEntry struct {
	Active    bool
	ModsMask  byte
	Level     byte
	ModsMods  byte
	ModsVmods uint16
	// padding: 2 bytes
}

// KTMapEntryRead reads a byte slice into a KTMapEntry value.
func KTMapEntryRead(buf []byte, v *KTMapEntry) int {
	b := 0

	if buf[b] == 1 {
		v.Active = true
	} else {
		v.Active = false
	}
	b += 1

	v.ModsMask = buf[b]
	b += 1

	v.Level = buf[b]
	b += 1

	v.ModsMods = buf[b]
	b += 1

	v.ModsVmods = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return b
}

// KTMapEntryReadList reads a byte slice into a list of KTMapEntry values.
func KTMapEntryReadList(buf []byte, dest []KTMapEntry) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KTMapEntry{}
		b += KTMapEntryRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KTMapEntry value to a byte slice.
func (v KTMapEntry) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	if v.Active {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.ModsMask
	b += 1

	buf[b] = v.Level
	b += 1

	buf[b] = v.ModsMods
	b += 1

	xgb.Put16(buf[b:], v.ModsVmods)
	b += 2

	b += 2 // padding

	return buf[:b]
}

// KTMapEntryListBytes writes a list of KTMapEntry values to a byte slice.
func KTMapEntryListBytes(buf []byte, list []KTMapEntry) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type KTSetMapEntry struct {
	Level       byte
	RealMods    byte
	VirtualMods uint16
}

// KTSetMapEntryRead reads a byte slice into a KTSetMapEntry value.
func KTSetMapEntryRead(buf []byte, v *KTSetMapEntry) int {
	b := 0

	v.Level = buf[b]
	b += 1

	v.RealMods = buf[b]
	b += 1

	v.VirtualMods = xgb.Get16(buf[b:])
	b += 2

	return b
}

// KTSetMapEntryReadList reads a byte slice into a list of KTSetMapEntry values.
func KTSetMapEntryReadList(buf []byte, dest []KTSetMapEntry) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KTSetMapEntry{}
		b += KTSetMapEntryRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KTSetMapEntry value to a byte slice.
func (v KTSetMapEntry) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.Level
	b += 1

	buf[b] = v.RealMods
	b += 1

	xgb.Put16(buf[b:], v.VirtualMods)
	b += 2

	return buf[:b]
}

// KTSetMapEntryListBytes writes a list of KTSetMapEntry values to a byte slice.
func KTSetMapEntryListBytes(buf []byte, list []KTSetMapEntry) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type Key struct {
	Name     []String8 // size: 4
	Gap      int16
	ShapeNdx byte
	ColorNdx byte
}

// KeyRead reads a byte slice into a Key value.
func KeyRead(buf []byte, v *Key) int {
	b := 0

	v.Name = make([]String8, 4)
	for i := 0; i < int(4); i++ {
		v.Name[i] = String8(buf[b])
		b += 1
	}

	v.Gap = int16(xgb.Get16(buf[b:]))
	b += 2

	v.ShapeNdx = buf[b]
	b += 1

	v.ColorNdx = buf[b]
	b += 1

	return b
}

// KeyReadList reads a byte slice into a list of Key values.
func KeyReadList(buf []byte, dest []Key) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Key{}
		b += KeyRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Key value to a byte slice.
func (v Key) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	for i := 0; i < int(4); i++ {
		buf[b] = byte(v.Name[i])
		b += 1
	}

	xgb.Put16(buf[b:], uint16(v.Gap))
	b += 2

	buf[b] = v.ShapeNdx
	b += 1

	buf[b] = v.ColorNdx
	b += 1

	return buf[:b]
}

// KeyListBytes writes a list of Key values to a byte slice.
func KeyListBytes(buf []byte, list []Key) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// KeyListSize computes the size (bytes) of a list of Key values.
func KeyListSize(list []Key) int {
	size := 0
	for _ = range list {
		size += 8
	}
	return size
}

type KeyAlias struct {
	Real  string // size: 4
	Alias string // size: 4
}

// KeyAliasRead reads a byte slice into a KeyAlias value.
func KeyAliasRead(buf []byte, v *KeyAlias) int {
	b := 0

	{
		byteString := make([]byte, 4)
		copy(byteString[:4], buf[b:])
		v.Real = string(byteString)
		b += int(4)
	}

	{
		byteString := make([]byte, 4)
		copy(byteString[:4], buf[b:])
		v.Alias = string(byteString)
		b += int(4)
	}

	return b
}

// KeyAliasReadList reads a byte slice into a list of KeyAlias values.
func KeyAliasReadList(buf []byte, dest []KeyAlias) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyAlias{}
		b += KeyAliasRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KeyAlias value to a byte slice.
func (v KeyAlias) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	copy(buf[b:], v.Real[:4])
	b += int(4)

	copy(buf[b:], v.Alias[:4])
	b += int(4)

	return buf[:b]
}

// KeyAliasListBytes writes a list of KeyAlias values to a byte slice.
func KeyAliasListBytes(buf []byte, list []KeyAlias) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// KeyAliasListSize computes the size (bytes) of a list of KeyAlias values.
func KeyAliasListSize(list []KeyAlias) int {
	size := 0
	for _ = range list {
		size += 8
	}
	return size
}

type KeyModMap struct {
	Keycode xproto.Keycode
	Mods    byte
}

// KeyModMapRead reads a byte slice into a KeyModMap value.
func KeyModMapRead(buf []byte, v *KeyModMap) int {
	b := 0

	v.Keycode = xproto.Keycode(buf[b])
	b += 1

	v.Mods = buf[b]
	b += 1

	return b
}

// KeyModMapReadList reads a byte slice into a list of KeyModMap values.
func KeyModMapReadList(buf []byte, dest []KeyModMap) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyModMap{}
		b += KeyModMapRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KeyModMap value to a byte slice.
func (v KeyModMap) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = byte(v.Keycode)
	b += 1

	buf[b] = v.Mods
	b += 1

	return buf[:b]
}

// KeyModMapListBytes writes a list of KeyModMap values to a byte slice.
func KeyModMapListBytes(buf []byte, list []KeyModMap) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type KeyName struct {
	Name string // size: 4
}

// KeyNameRead reads a byte slice into a KeyName value.
func KeyNameRead(buf []byte, v *KeyName) int {
	b := 0

	{
		byteString := make([]byte, 4)
		copy(byteString[:4], buf[b:])
		v.Name = string(byteString)
		b += int(4)
	}

	return b
}

// KeyNameReadList reads a byte slice into a list of KeyName values.
func KeyNameReadList(buf []byte, dest []KeyName) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyName{}
		b += KeyNameRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KeyName value to a byte slice.
func (v KeyName) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	copy(buf[b:], v.Name[:4])
	b += int(4)

	return buf[:b]
}

// KeyNameListBytes writes a list of KeyName values to a byte slice.
func KeyNameListBytes(buf []byte, list []KeyName) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// KeyNameListSize computes the size (bytes) of a list of KeyName values.
func KeyNameListSize(list []KeyName) int {
	size := 0
	for _ = range list {
		size += 4
	}
	return size
}

type KeySymMap struct {
	KtIndex   []byte // size: 4
	GroupInfo byte
	Width     byte
	NSyms     uint16
	Syms      []xproto.Keysym // size: xgb.Pad((int(NSyms) * 4))
}

// KeySymMapRead reads a byte slice into a KeySymMap value.
func KeySymMapRead(buf []byte, v *KeySymMap) int {
	b := 0

	v.KtIndex = make([]byte, 4)
	copy(v.KtIndex[:4], buf[b:])
	b += int(4)

	v.GroupInfo = buf[b]
	b += 1

	v.Width = buf[b]
	b += 1

	v.NSyms = xgb.Get16(buf[b:])
	b += 2

	v.Syms = make([]xproto.Keysym, v.NSyms)
	for i := 0; i < int(v.NSyms); i++ {
		v.Syms[i] = xproto.Keysym(xgb.Get32(buf[b:]))
		b += 4
	}

	return b
}

// KeySymMapReadList reads a byte slice into a list of KeySymMap values.
func KeySymMapReadList(buf []byte, dest []KeySymMap) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeySymMap{}
		b += KeySymMapRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KeySymMap value to a byte slice.
func (v KeySymMap) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.NSyms) * 4))))
	b := 0

	copy(buf[b:], v.KtIndex[:4])
	b += int(4)

	buf[b] = v.GroupInfo
	b += 1

	buf[b] = v.Width
	b += 1

	xgb.Put16(buf[b:], v.NSyms)
	b += 2

	for i := 0; i < int(v.NSyms); i++ {
		xgb.Put32(buf[b:], uint32(v.Syms[i]))
		b += 4
	}

	return buf[:b]
}

// KeySymMapListBytes writes a list of KeySymMap values to a byte slice.
func KeySymMapListBytes(buf []byte, list []KeySymMap) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// KeySymMapListSize computes the size (bytes) of a list of KeySymMap values.
func KeySymMapListSize(list []KeySymMap) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.NSyms) * 4)))
	}
	return size
}

type KeyType struct {
	ModsMask    byte
	ModsMods    byte
	ModsVmods   uint16
	NumLevels   byte
	NMapEntries byte
	HasPreserve bool
	// padding: 1 bytes
	Map      []KTMapEntry // size: xgb.Pad((int(NMapEntries) * 8))
	Preserve []ModDef     // size: xgb.Pad(((int(HasPreserve) * int(NMapEntries)) * 4))
}

// KeyTypeRead reads a byte slice into a KeyType value.
func KeyTypeRead(buf []byte, v *KeyType) int {
	b := 0

	v.ModsMask = buf[b]
	b += 1

	v.ModsMods = buf[b]
	b += 1

	v.ModsVmods = xgb.Get16(buf[b:])
	b += 2

	v.NumLevels = buf[b]
	b += 1

	v.NMapEntries = buf[b]
	b += 1

	if buf[b] == 1 {
		v.HasPreserve = true
	} else {
		v.HasPreserve = false
	}
	b += 1

	b += 1 // padding

	v.Map = make([]KTMapEntry, v.NMapEntries)
	b += KTMapEntryReadList(buf[b:], v.Map)

	v.Preserve = make([]ModDef, (int(v.HasPreserve) * int(v.NMapEntries)))
	b += ModDefReadList(buf[b:], v.Preserve)

	return b
}

// KeyTypeReadList reads a byte slice into a list of KeyType values.
func KeyTypeReadList(buf []byte, dest []KeyType) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyType{}
		b += KeyTypeRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KeyType value to a byte slice.
func (v KeyType) Bytes() []byte {
	buf := make([]byte, ((8 + xgb.Pad((int(v.NMapEntries) * 8))) + xgb.Pad(((int(v.HasPreserve) * int(v.NMapEntries)) * 4))))
	b := 0

	buf[b] = v.ModsMask
	b += 1

	buf[b] = v.ModsMods
	b += 1

	xgb.Put16(buf[b:], v.ModsVmods)
	b += 2

	buf[b] = v.NumLevels
	b += 1

	buf[b] = v.NMapEntries
	b += 1

	if v.HasPreserve {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	b += KTMapEntryListBytes(buf[b:], v.Map)

	b += ModDefListBytes(buf[b:], v.Preserve)

	return buf[:b]
}

// KeyTypeListBytes writes a list of KeyType values to a byte slice.
func KeyTypeListBytes(buf []byte, list []KeyType) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// KeyTypeListSize computes the size (bytes) of a list of KeyType values.
func KeyTypeListSize(list []KeyType) int {
	size := 0
	for _, item := range list {
		size += ((8 + xgb.Pad((int(item.NMapEntries) * 8))) + xgb.Pad(((int(item.HasPreserve) * int(item.NMapEntries)) * 4)))
	}
	return size
}

type KeyVModMap struct {
	Keycode xproto.Keycode
	// padding: 1 bytes
	Vmods uint16
}

// KeyVModMapRead reads a byte slice into a KeyVModMap value.
func KeyVModMapRead(buf []byte, v *KeyVModMap) int {
	b := 0

	v.Keycode = xproto.Keycode(buf[b])
	b += 1

	b += 1 // padding

	v.Vmods = xgb.Get16(buf[b:])
	b += 2

	return b
}

// KeyVModMapReadList reads a byte slice into a list of KeyVModMap values.
func KeyVModMapReadList(buf []byte, dest []KeyVModMap) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyVModMap{}
		b += KeyVModMapRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KeyVModMap value to a byte slice.
func (v KeyVModMap) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = byte(v.Keycode)
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], v.Vmods)
	b += 2

	return buf[:b]
}

// KeyVModMapListBytes writes a list of KeyVModMap values to a byte slice.
func KeyVModMapListBytes(buf []byte, list []KeyVModMap) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// BadKeyboard is the error number for a BadKeyboard.
const BadKeyboard = 0

type KeyboardError struct {
	Sequence    uint16
	NiceName    string
	Value       uint32
	MinorOpcode uint16
	MajorOpcode byte
	// padding: 21 bytes
}

// KeyboardErrorNew constructs a KeyboardError value that implements xgb.Error from a byte slice.
func KeyboardErrorNew(buf []byte) xgb.Error {
	v := KeyboardError{}
	v.NiceName = "Keyboard"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Value = xgb.Get32(buf[b:])
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	b += 21 // padding

	return v
}

// SequenceId returns the sequence id attached to the BadKeyboard error.
// This is mostly used internally.
func (err KeyboardError) SequenceId() uint16 {
	return err.Sequence
}

// BadId returns the 'BadValue' number if one exists for the BadKeyboard error. If no bad value exists, 0 is returned.
func (err KeyboardError) BadId() uint32 {
	return 0
}

// Error returns a rudimentary string representation of the BadKeyboard error.

func (err KeyboardError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Value: %d", err.Value))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadKeyboard {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XKEYBOARD"][0] = KeyboardErrorNew
}

const (
	LedClassKbdFeedbackClass = 0
	LedClassLedFeedbackClass = 4
	LedClassDfltXIClass      = 768
	LedClassAllXIClasses     = 1280
)

const (
	LedClassResultKbdFeedbackClass = 0
	LedClassResultLedFeedbackClass = 4
)

type LedClassSpec uint16

type Listing struct {
	Flags  uint16
	Length uint16
	String []String8 // size: xgb.Pad((int(Length) * 1))
	// alignment gap to multiple of 2
}

// ListingRead reads a byte slice into a Listing value.
func ListingRead(buf []byte, v *Listing) int {
	b := 0

	v.Flags = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get16(buf[b:])
	b += 2

	v.String = make([]String8, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.String[i] = String8(buf[b])
		b += 1
	}

	b = (b + 1) & ^1 // alignment gap

	return b
}

// ListingReadList reads a byte slice into a list of Listing values.
func ListingReadList(buf []byte, dest []Listing) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Listing{}
		b += ListingRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Listing value to a byte slice.
func (v Listing) Bytes() []byte {
	buf := make([]byte, ((4 + xgb.Pad((int(v.Length) * 1))) + 2))
	b := 0

	xgb.Put16(buf[b:], v.Flags)
	b += 2

	xgb.Put16(buf[b:], v.Length)
	b += 2

	for i := 0; i < int(v.Length); i++ {
		buf[b] = byte(v.String[i])
		b += 1
	}

	b = (b + 1) & ^1 // alignment gap

	return buf[:b]
}

// ListingListBytes writes a list of Listing values to a byte slice.
func ListingListBytes(buf []byte, list []Listing) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// ListingListSize computes the size (bytes) of a list of Listing values.
func ListingListSize(list []Listing) int {
	size := 0
	for _, item := range list {
		size += ((4 + xgb.Pad((int(item.Length) * 1))) + 2)
	}
	return size
}

type LockBehavior DefaultBehavior

const (
	LockDeviceFlagsNoLock   = 1
	LockDeviceFlagsNoUnlock = 2
)

// MapNotify is the event number for a MapNotifyEvent.
const MapNotify = 1

type MapNotifyEvent struct {
	Sequence         uint16
	XkbType          byte
	Time             xproto.Timestamp
	DeviceID         byte
	PtrBtnActions    byte
	Changed          uint16
	MinKeyCode       xproto.Keycode
	MaxKeyCode       xproto.Keycode
	FirstType        byte
	NTypes           byte
	FirstKeySym      xproto.Keycode
	NKeySyms         byte
	FirstKeyAct      xproto.Keycode
	NKeyActs         byte
	FirstKeyBehavior xproto.Keycode
	NKeyBehavior     byte
	FirstKeyExplicit xproto.Keycode
	NKeyExplicit     byte
	FirstModMapKey   xproto.Keycode
	NModMapKeys      byte
	FirstVModMapKey  xproto.Keycode
	NVModMapKeys     byte
	VirtualMods      uint16
	// padding: 2 bytes
}

// MapNotifyEventNew constructs a MapNotifyEvent value that implements xgb.Event from a byte slice.
func MapNotifyEventNew(buf []byte) xgb.Event {
	v := MapNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	v.PtrBtnActions = buf[b]
	b += 1

	v.Changed = xgb.Get16(buf[b:])
	b += 2

	v.MinKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.MaxKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.FirstType = buf[b]
	b += 1

	v.NTypes = buf[b]
	b += 1

	v.FirstKeySym = xproto.Keycode(buf[b])
	b += 1

	v.NKeySyms = buf[b]
	b += 1

	v.FirstKeyAct = xproto.Keycode(buf[b])
	b += 1

	v.NKeyActs = buf[b]
	b += 1

	v.FirstKeyBehavior = xproto.Keycode(buf[b])
	b += 1

	v.NKeyBehavior = buf[b]
	b += 1

	v.FirstKeyExplicit = xproto.Keycode(buf[b])
	b += 1

	v.NKeyExplicit = buf[b]
	b += 1

	v.FirstModMapKey = xproto.Keycode(buf[b])
	b += 1

	v.NModMapKeys = buf[b]
	b += 1

	v.FirstVModMapKey = xproto.Keycode(buf[b])
	b += 1

	v.NVModMapKeys = buf[b]
	b += 1

	v.VirtualMods = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return v
}

// Bytes writes a MapNotifyEvent value to a byte slice.
func (v MapNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	buf[b] = v.PtrBtnActions
	b += 1

	xgb.Put16(buf[b:], v.Changed)
	b += 2

	buf[b] = byte(v.MinKeyCode)
	b += 1

	buf[b] = byte(v.MaxKeyCode)
	b += 1

	buf[b] = v.FirstType
	b += 1

	buf[b] = v.NTypes
	b += 1

	buf[b] = byte(v.FirstKeySym)
	b += 1

	buf[b] = v.NKeySyms
	b += 1

	buf[b] = byte(v.FirstKeyAct)
	b += 1

	buf[b] = v.NKeyActs
	b += 1

	buf[b] = byte(v.FirstKeyBehavior)
	b += 1

	buf[b] = v.NKeyBehavior
	b += 1

	buf[b] = byte(v.FirstKeyExplicit)
	b += 1

	buf[b] = v.NKeyExplicit
	b += 1

	buf[b] = byte(v.FirstModMapKey)
	b += 1

	buf[b] = v.NModMapKeys
	b += 1

	buf[b] = byte(v.FirstVModMapKey)
	b += 1

	buf[b] = v.NVModMapKeys
	b += 1

	xgb.Put16(buf[b:], v.VirtualMods)
	b += 2

	b += 2 // padding

	return buf
}

// SequenceId returns the sequence id attached to the MapNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v MapNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of MapNotifyEvent.
func (v MapNotifyEvent) String() string {
	fieldVals := make([]string, 0, 23)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("PtrBtnActions: %d", v.PtrBtnActions))
	fieldVals = append(fieldVals, xgb.Sprintf("Changed: %d", v.Changed))
	fieldVals = append(fieldVals, xgb.Sprintf("MinKeyCode: %d", v.MinKeyCode))
	fieldVals = append(fieldVals, xgb.Sprintf("MaxKeyCode: %d", v.MaxKeyCode))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstType: %d", v.FirstType))
	fieldVals = append(fieldVals, xgb.Sprintf("NTypes: %d", v.NTypes))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstKeySym: %d", v.FirstKeySym))
	fieldVals = append(fieldVals, xgb.Sprintf("NKeySyms: %d", v.NKeySyms))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstKeyAct: %d", v.FirstKeyAct))
	fieldVals = append(fieldVals, xgb.Sprintf("NKeyActs: %d", v.NKeyActs))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstKeyBehavior: %d", v.FirstKeyBehavior))
	fieldVals = append(fieldVals, xgb.Sprintf("NKeyBehavior: %d", v.NKeyBehavior))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstKeyExplicit: %d", v.FirstKeyExplicit))
	fieldVals = append(fieldVals, xgb.Sprintf("NKeyExplicit: %d", v.NKeyExplicit))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstModMapKey: %d", v.FirstModMapKey))
	fieldVals = append(fieldVals, xgb.Sprintf("NModMapKeys: %d", v.NModMapKeys))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstVModMapKey: %d", v.FirstVModMapKey))
	fieldVals = append(fieldVals, xgb.Sprintf("NVModMapKeys: %d", v.NVModMapKeys))
	fieldVals = append(fieldVals, xgb.Sprintf("VirtualMods: %d", v.VirtualMods))
	return "MapNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][1] = MapNotifyEventNew
}

const (
	MapPartKeyTypes           = 1
	MapPartKeySyms            = 2
	MapPartModifierMap        = 4
	MapPartExplicitComponents = 8
	MapPartKeyActions         = 16
	MapPartKeyBehaviors       = 32
	MapPartVirtualMods        = 64
	MapPartVirtualModMap      = 128
)

type ModDef struct {
	Mask     byte
	RealMods byte
	Vmods    uint16
}

// ModDefRead reads a byte slice into a ModDef value.
func ModDefRead(buf []byte, v *ModDef) int {
	b := 0

	v.Mask = buf[b]
	b += 1

	v.RealMods = buf[b]
	b += 1

	v.Vmods = xgb.Get16(buf[b:])
	b += 2

	return b
}

// ModDefReadList reads a byte slice into a list of ModDef values.
func ModDefReadList(buf []byte, dest []ModDef) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ModDef{}
		b += ModDefRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a ModDef value to a byte slice.
func (v ModDef) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.Mask
	b += 1

	buf[b] = v.RealMods
	b += 1

	xgb.Put16(buf[b:], v.Vmods)
	b += 2

	return buf[:b]
}

// ModDefListBytes writes a list of ModDef values to a byte slice.
func ModDefListBytes(buf []byte, list []ModDef) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

const (
	NKNDetailKeycodes = 1
	NKNDetailGeometry = 2
	NKNDetailDeviceID = 4
)

const (
	NameDetailKeycodes        = 1
	NameDetailGeometry        = 2
	NameDetailSymbols         = 4
	NameDetailPhysSymbols     = 8
	NameDetailTypes           = 16
	NameDetailCompat          = 32
	NameDetailKeyTypeNames    = 64
	NameDetailKTLevelNames    = 128
	NameDetailIndicatorNames  = 256
	NameDetailKeyNames        = 512
	NameDetailKeyAliases      = 1024
	NameDetailVirtualModNames = 2048
	NameDetailGroupNames      = 4096
	NameDetailRGNames         = 8192
)

// NamesNotify is the event number for a NamesNotifyEvent.
const NamesNotify = 6

type NamesNotifyEvent struct {
	Sequence uint16
	XkbType  byte
	Time     xproto.Timestamp
	DeviceID byte
	// padding: 1 bytes
	Changed        uint16
	FirstType      byte
	NTypes         byte
	FirstLevelName byte
	NLevelNames    byte
	// padding: 1 bytes
	NRadioGroups       byte
	NKeyAliases        byte
	ChangedGroupNames  byte
	ChangedVirtualMods uint16
	FirstKey           xproto.Keycode
	NKeys              byte
	ChangedIndicators  uint32
	// padding: 4 bytes
}

// NamesNotifyEventNew constructs a NamesNotifyEvent value that implements xgb.Event from a byte slice.
func NamesNotifyEventNew(buf []byte) xgb.Event {
	v := NamesNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	b += 1 // padding

	v.Changed = xgb.Get16(buf[b:])
	b += 2

	v.FirstType = buf[b]
	b += 1

	v.NTypes = buf[b]
	b += 1

	v.FirstLevelName = buf[b]
	b += 1

	v.NLevelNames = buf[b]
	b += 1

	b += 1 // padding

	v.NRadioGroups = buf[b]
	b += 1

	v.NKeyAliases = buf[b]
	b += 1

	v.ChangedGroupNames = buf[b]
	b += 1

	v.ChangedVirtualMods = xgb.Get16(buf[b:])
	b += 2

	v.FirstKey = xproto.Keycode(buf[b])
	b += 1

	v.NKeys = buf[b]
	b += 1

	v.ChangedIndicators = xgb.Get32(buf[b:])
	b += 4

	b += 4 // padding

	return v
}

// Bytes writes a NamesNotifyEvent value to a byte slice.
func (v NamesNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 6
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], v.Changed)
	b += 2

	buf[b] = v.FirstType
	b += 1

	buf[b] = v.NTypes
	b += 1

	buf[b] = v.FirstLevelName
	b += 1

	buf[b] = v.NLevelNames
	b += 1

	b += 1 // padding

	buf[b] = v.NRadioGroups
	b += 1

	buf[b] = v.NKeyAliases
	b += 1

	buf[b] = v.ChangedGroupNames
	b += 1

	xgb.Put16(buf[b:], v.ChangedVirtualMods)
	b += 2

	buf[b] = byte(v.FirstKey)
	b += 1

	buf[b] = v.NKeys
	b += 1

	xgb.Put32(buf[b:], v.ChangedIndicators)
	b += 4

	b += 4 // padding

	return buf
}

// SequenceId returns the sequence id attached to the NamesNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v NamesNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of NamesNotifyEvent.
func (v NamesNotifyEvent) String() string {
	fieldVals := make([]string, 0, 18)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("Changed: %d", v.Changed))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstType: %d", v.FirstType))
	fieldVals = append(fieldVals, xgb.Sprintf("NTypes: %d", v.NTypes))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstLevelName: %d", v.FirstLevelName))
	fieldVals = append(fieldVals, xgb.Sprintf("NLevelNames: %d", v.NLevelNames))
	fieldVals = append(fieldVals, xgb.Sprintf("NRadioGroups: %d", v.NRadioGroups))
	fieldVals = append(fieldVals, xgb.Sprintf("NKeyAliases: %d", v.NKeyAliases))
	fieldVals = append(fieldVals, xgb.Sprintf("ChangedGroupNames: %d", v.ChangedGroupNames))
	fieldVals = append(fieldVals, xgb.Sprintf("ChangedVirtualMods: %d", v.ChangedVirtualMods))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstKey: %d", v.FirstKey))
	fieldVals = append(fieldVals, xgb.Sprintf("NKeys: %d", v.NKeys))
	fieldVals = append(fieldVals, xgb.Sprintf("ChangedIndicators: %d", v.ChangedIndicators))
	return "NamesNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][6] = NamesNotifyEventNew
}

// NewKeyboardNotify is the event number for a NewKeyboardNotifyEvent.
const NewKeyboardNotify = 0

type NewKeyboardNotifyEvent struct {
	Sequence      uint16
	XkbType       byte
	Time          xproto.Timestamp
	DeviceID      byte
	OldDeviceID   byte
	MinKeyCode    xproto.Keycode
	MaxKeyCode    xproto.Keycode
	OldMinKeyCode xproto.Keycode
	OldMaxKeyCode xproto.Keycode
	RequestMajor  byte
	RequestMinor  byte
	Changed       uint16
	// padding: 14 bytes
}

// NewKeyboardNotifyEventNew constructs a NewKeyboardNotifyEvent value that implements xgb.Event from a byte slice.
func NewKeyboardNotifyEventNew(buf []byte) xgb.Event {
	v := NewKeyboardNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	v.OldDeviceID = buf[b]
	b += 1

	v.MinKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.MaxKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.OldMinKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.OldMaxKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.RequestMajor = buf[b]
	b += 1

	v.RequestMinor = buf[b]
	b += 1

	v.Changed = xgb.Get16(buf[b:])
	b += 2

	b += 14 // padding

	return v
}

// Bytes writes a NewKeyboardNotifyEvent value to a byte slice.
func (v NewKeyboardNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	buf[b] = v.OldDeviceID
	b += 1

	buf[b] = byte(v.MinKeyCode)
	b += 1

	buf[b] = byte(v.MaxKeyCode)
	b += 1

	buf[b] = byte(v.OldMinKeyCode)
	b += 1

	buf[b] = byte(v.OldMaxKeyCode)
	b += 1

	buf[b] = v.RequestMajor
	b += 1

	buf[b] = v.RequestMinor
	b += 1

	xgb.Put16(buf[b:], v.Changed)
	b += 2

	b += 14 // padding

	return buf
}

// SequenceId returns the sequence id attached to the NewKeyboardNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v NewKeyboardNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of NewKeyboardNotifyEvent.
func (v NewKeyboardNotifyEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("OldDeviceID: %d", v.OldDeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("MinKeyCode: %d", v.MinKeyCode))
	fieldVals = append(fieldVals, xgb.Sprintf("MaxKeyCode: %d", v.MaxKeyCode))
	fieldVals = append(fieldVals, xgb.Sprintf("OldMinKeyCode: %d", v.OldMinKeyCode))
	fieldVals = append(fieldVals, xgb.Sprintf("OldMaxKeyCode: %d", v.OldMaxKeyCode))
	fieldVals = append(fieldVals, xgb.Sprintf("RequestMajor: %d", v.RequestMajor))
	fieldVals = append(fieldVals, xgb.Sprintf("RequestMinor: %d", v.RequestMinor))
	fieldVals = append(fieldVals, xgb.Sprintf("Changed: %d", v.Changed))
	return "NewKeyboardNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][0] = NewKeyboardNotifyEventNew
}

type Outline struct {
	NPoints      byte
	CornerRadius byte
	// padding: 2 bytes
	Points []xproto.Point // size: xgb.Pad((int(NPoints) * 4))
}

// OutlineRead reads a byte slice into a Outline value.
func OutlineRead(buf []byte, v *Outline) int {
	b := 0

	v.NPoints = buf[b]
	b += 1

	v.CornerRadius = buf[b]
	b += 1

	b += 2 // padding

	v.Points = make([]xproto.Point, v.NPoints)
	b += xproto.PointReadList(buf[b:], v.Points)

	return b
}

// OutlineReadList reads a byte slice into a list of Outline values.
func OutlineReadList(buf []byte, dest []Outline) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Outline{}
		b += OutlineRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Outline value to a byte slice.
func (v Outline) Bytes() []byte {
	buf := make([]byte, (4 + xgb.Pad((int(v.NPoints) * 4))))
	b := 0

	buf[b] = v.NPoints
	b += 1

	buf[b] = v.CornerRadius
	b += 1

	b += 2 // padding

	b += xproto.PointListBytes(buf[b:], v.Points)

	return buf[:b]
}

// OutlineListBytes writes a list of Outline values to a byte slice.
func OutlineListBytes(buf []byte, list []Outline) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// OutlineListSize computes the size (bytes) of a list of Outline values.
func OutlineListSize(list []Outline) int {
	size := 0
	for _, item := range list {
		size += (4 + xgb.Pad((int(item.NPoints) * 4)))
	}
	return size
}

type Overlay struct {
	Name  xproto.Atom
	NRows byte
	// padding: 3 bytes
	Rows []OverlayRow // size: OverlayRowListSize(Rows)
}

// OverlayRead reads a byte slice into a Overlay value.
func OverlayRead(buf []byte, v *Overlay) int {
	b := 0

	v.Name = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.NRows = buf[b]
	b += 1

	b += 3 // padding

	v.Rows = make([]OverlayRow, v.NRows)
	b += OverlayRowReadList(buf[b:], v.Rows)

	return b
}

// OverlayReadList reads a byte slice into a list of Overlay values.
func OverlayReadList(buf []byte, dest []Overlay) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Overlay{}
		b += OverlayRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Overlay value to a byte slice.
func (v Overlay) Bytes() []byte {
	buf := make([]byte, (8 + OverlayRowListSize(v.Rows)))
	b := 0

	xgb.Put32(buf[b:], uint32(v.Name))
	b += 4

	buf[b] = v.NRows
	b += 1

	b += 3 // padding

	b += OverlayRowListBytes(buf[b:], v.Rows)

	return buf[:b]
}

// OverlayListBytes writes a list of Overlay values to a byte slice.
func OverlayListBytes(buf []byte, list []Overlay) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// OverlayListSize computes the size (bytes) of a list of Overlay values.
func OverlayListSize(list []Overlay) int {
	size := 0
	for _, item := range list {
		size += (8 + OverlayRowListSize(item.Rows))
	}
	return size
}

type OverlayBehavior struct {
	Type byte
	Key  xproto.Keycode
}

// OverlayBehaviorRead reads a byte slice into a OverlayBehavior value.
func OverlayBehaviorRead(buf []byte, v *OverlayBehavior) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Key = xproto.Keycode(buf[b])
	b += 1

	return b
}

// OverlayBehaviorReadList reads a byte slice into a list of OverlayBehavior values.
func OverlayBehaviorReadList(buf []byte, dest []OverlayBehavior) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = OverlayBehavior{}
		b += OverlayBehaviorRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a OverlayBehavior value to a byte slice.
func (v OverlayBehavior) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = byte(v.Key)
	b += 1

	return buf[:b]
}

// OverlayBehaviorListBytes writes a list of OverlayBehavior values to a byte slice.
func OverlayBehaviorListBytes(buf []byte, list []OverlayBehavior) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type OverlayKey struct {
	Over  []String8 // size: 4
	Under []String8 // size: 4
}

// OverlayKeyRead reads a byte slice into a OverlayKey value.
func OverlayKeyRead(buf []byte, v *OverlayKey) int {
	b := 0

	v.Over = make([]String8, 4)
	for i := 0; i < int(4); i++ {
		v.Over[i] = String8(buf[b])
		b += 1
	}

	v.Under = make([]String8, 4)
	for i := 0; i < int(4); i++ {
		v.Under[i] = String8(buf[b])
		b += 1
	}

	return b
}

// OverlayKeyReadList reads a byte slice into a list of OverlayKey values.
func OverlayKeyReadList(buf []byte, dest []OverlayKey) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = OverlayKey{}
		b += OverlayKeyRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a OverlayKey value to a byte slice.
func (v OverlayKey) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	for i := 0; i < int(4); i++ {
		buf[b] = byte(v.Over[i])
		b += 1
	}

	for i := 0; i < int(4); i++ {
		buf[b] = byte(v.Under[i])
		b += 1
	}

	return buf[:b]
}

// OverlayKeyListBytes writes a list of OverlayKey values to a byte slice.
func OverlayKeyListBytes(buf []byte, list []OverlayKey) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// OverlayKeyListSize computes the size (bytes) of a list of OverlayKey values.
func OverlayKeyListSize(list []OverlayKey) int {
	size := 0
	for _ = range list {
		size += 8
	}
	return size
}

type OverlayRow struct {
	RowUnder byte
	NKeys    byte
	// padding: 2 bytes
	Keys []OverlayKey // size: OverlayKeyListSize(Keys)
}

// OverlayRowRead reads a byte slice into a OverlayRow value.
func OverlayRowRead(buf []byte, v *OverlayRow) int {
	b := 0

	v.RowUnder = buf[b]
	b += 1

	v.NKeys = buf[b]
	b += 1

	b += 2 // padding

	v.Keys = make([]OverlayKey, v.NKeys)
	b += OverlayKeyReadList(buf[b:], v.Keys)

	return b
}

// OverlayRowReadList reads a byte slice into a list of OverlayRow values.
func OverlayRowReadList(buf []byte, dest []OverlayRow) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = OverlayRow{}
		b += OverlayRowRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a OverlayRow value to a byte slice.
func (v OverlayRow) Bytes() []byte {
	buf := make([]byte, (4 + OverlayKeyListSize(v.Keys)))
	b := 0

	buf[b] = v.RowUnder
	b += 1

	buf[b] = v.NKeys
	b += 1

	b += 2 // padding

	b += OverlayKeyListBytes(buf[b:], v.Keys)

	return buf[:b]
}

// OverlayRowListBytes writes a list of OverlayRow values to a byte slice.
func OverlayRowListBytes(buf []byte, list []OverlayRow) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// OverlayRowListSize computes the size (bytes) of a list of OverlayRow values.
func OverlayRowListSize(list []OverlayRow) int {
	size := 0
	for _, item := range list {
		size += (4 + OverlayKeyListSize(item.Keys))
	}
	return size
}

const (
	PerClientFlagDetectableAutoRepeat   = 1
	PerClientFlagGrabsUseXKBState       = 2
	PerClientFlagAutoResetControls      = 4
	PerClientFlagLookupStateWhenGrabbed = 8
	PerClientFlagSendEventUsesXKBState  = 16
)

type PermamentLockBehavior LockBehavior

type PermamentOverlayBehavior OverlayBehavior

type PermamentRadioGroupBehavior RadioGroupBehavior

type RadioGroupBehavior struct {
	Type  byte
	Group byte
}

// RadioGroupBehaviorRead reads a byte slice into a RadioGroupBehavior value.
func RadioGroupBehaviorRead(buf []byte, v *RadioGroupBehavior) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Group = buf[b]
	b += 1

	return b
}

// RadioGroupBehaviorReadList reads a byte slice into a list of RadioGroupBehavior values.
func RadioGroupBehaviorReadList(buf []byte, dest []RadioGroupBehavior) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = RadioGroupBehavior{}
		b += RadioGroupBehaviorRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a RadioGroupBehavior value to a byte slice.
func (v RadioGroupBehavior) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Group
	b += 1

	return buf[:b]
}

// RadioGroupBehaviorListBytes writes a list of RadioGroupBehavior values to a byte slice.
func RadioGroupBehaviorListBytes(buf []byte, list []RadioGroupBehavior) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type Row struct {
	Top      int16
	Left     int16
	NKeys    byte
	Vertical bool
	// padding: 2 bytes
	Keys []Key // size: KeyListSize(Keys)
}

// RowRead reads a byte slice into a Row value.
func RowRead(buf []byte, v *Row) int {
	b := 0

	v.Top = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Left = int16(xgb.Get16(buf[b:]))
	b += 2

	v.NKeys = buf[b]
	b += 1

	if buf[b] == 1 {
		v.Vertical = true
	} else {
		v.Vertical = false
	}
	b += 1

	b += 2 // padding

	v.Keys = make([]Key, v.NKeys)
	b += KeyReadList(buf[b:], v.Keys)

	return b
}

// RowReadList reads a byte slice into a list of Row values.
func RowReadList(buf []byte, dest []Row) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Row{}
		b += RowRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Row value to a byte slice.
func (v Row) Bytes() []byte {
	buf := make([]byte, (8 + KeyListSize(v.Keys)))
	b := 0

	xgb.Put16(buf[b:], uint16(v.Top))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Left))
	b += 2

	buf[b] = v.NKeys
	b += 1

	if v.Vertical {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 2 // padding

	b += KeyListBytes(buf[b:], v.Keys)

	return buf[:b]
}

// RowListBytes writes a list of Row values to a byte slice.
func RowListBytes(buf []byte, list []Row) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// RowListSize computes the size (bytes) of a list of Row values.
func RowListSize(list []Row) int {
	size := 0
	for _, item := range list {
		size += (8 + KeyListSize(item.Keys))
	}
	return size
}

type SAActionMessage struct {
	Type    byte
	Flags   byte
	Message []byte // size: 8
}

// SAActionMessageRead reads a byte slice into a SAActionMessage value.
func SAActionMessageRead(buf []byte, v *SAActionMessage) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.Message = make([]byte, 6)
	copy(v.Message[:6], buf[b:])
	b += int(6)

	return b
}

// SAActionMessageReadList reads a byte slice into a list of SAActionMessage values.
func SAActionMessageReadList(buf []byte, dest []SAActionMessage) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SAActionMessage{}
		b += SAActionMessageRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SAActionMessage value to a byte slice.
func (v SAActionMessage) Bytes() []byte {
	buf := make([]byte, 10)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	copy(buf[b:], v.Message[:6])
	b += int(6)

	return buf[:b]
}

// SAActionMessageListBytes writes a list of SAActionMessage values to a byte slice.
func SAActionMessageListBytes(buf []byte, list []SAActionMessage) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// SAActionMessageListSize computes the size (bytes) of a list of SAActionMessage values.
func SAActionMessageListSize(list []SAActionMessage) int {
	size := 0
	for _ = range list {
		size += 10
	}
	return size
}

type SADeviceBtn struct {
	Type   byte
	Flags  byte
	Count  byte
	Button byte
	Device byte
	// padding: 3 bytes
}

// SADeviceBtnRead reads a byte slice into a SADeviceBtn value.
func SADeviceBtnRead(buf []byte, v *SADeviceBtn) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.Count = buf[b]
	b += 1

	v.Button = buf[b]
	b += 1

	v.Device = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// SADeviceBtnReadList reads a byte slice into a list of SADeviceBtn values.
func SADeviceBtnReadList(buf []byte, dest []SADeviceBtn) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SADeviceBtn{}
		b += SADeviceBtnRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SADeviceBtn value to a byte slice.
func (v SADeviceBtn) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	buf[b] = v.Count
	b += 1

	buf[b] = v.Button
	b += 1

	buf[b] = v.Device
	b += 1

	b += 3 // padding

	return buf[:b]
}

// SADeviceBtnListBytes writes a list of SADeviceBtn values to a byte slice.
func SADeviceBtnListBytes(buf []byte, list []SADeviceBtn) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SADeviceValuator struct {
	Type      byte
	Device    byte
	Val1what  byte
	Val1index byte
	Val1value byte
	Val2what  byte
	Val2index byte
	Val2value byte
}

// SADeviceValuatorRead reads a byte slice into a SADeviceValuator value.
func SADeviceValuatorRead(buf []byte, v *SADeviceValuator) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Device = buf[b]
	b += 1

	v.Val1what = buf[b]
	b += 1

	v.Val1index = buf[b]
	b += 1

	v.Val1value = buf[b]
	b += 1

	v.Val2what = buf[b]
	b += 1

	v.Val2index = buf[b]
	b += 1

	v.Val2value = buf[b]
	b += 1

	return b
}

// SADeviceValuatorReadList reads a byte slice into a list of SADeviceValuator values.
func SADeviceValuatorReadList(buf []byte, dest []SADeviceValuator) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SADeviceValuator{}
		b += SADeviceValuatorRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SADeviceValuator value to a byte slice.
func (v SADeviceValuator) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Device
	b += 1

	buf[b] = v.Val1what
	b += 1

	buf[b] = v.Val1index
	b += 1

	buf[b] = v.Val1value
	b += 1

	buf[b] = v.Val2what
	b += 1

	buf[b] = v.Val2index
	b += 1

	buf[b] = v.Val2value
	b += 1

	return buf[:b]
}

// SADeviceValuatorListBytes writes a list of SADeviceValuator values to a byte slice.
func SADeviceValuatorListBytes(buf []byte, list []SADeviceValuator) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SAIsoLock struct {
	Type      byte
	Flags     byte
	Mask      byte
	RealMods  byte
	Group     int8
	Affect    byte
	VmodsHigh byte
	VmodsLow  byte
}

// SAIsoLockRead reads a byte slice into a SAIsoLock value.
func SAIsoLockRead(buf []byte, v *SAIsoLock) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.Mask = buf[b]
	b += 1

	v.RealMods = buf[b]
	b += 1

	v.Group = int8(buf[b])
	b += 1

	v.Affect = buf[b]
	b += 1

	v.VmodsHigh = buf[b]
	b += 1

	v.VmodsLow = buf[b]
	b += 1

	return b
}

// SAIsoLockReadList reads a byte slice into a list of SAIsoLock values.
func SAIsoLockReadList(buf []byte, dest []SAIsoLock) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SAIsoLock{}
		b += SAIsoLockRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SAIsoLock value to a byte slice.
func (v SAIsoLock) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	buf[b] = v.Mask
	b += 1

	buf[b] = v.RealMods
	b += 1

	buf[b] = byte(v.Group)
	b += 1

	buf[b] = v.Affect
	b += 1

	buf[b] = v.VmodsHigh
	b += 1

	buf[b] = v.VmodsLow
	b += 1

	return buf[:b]
}

// SAIsoLockListBytes writes a list of SAIsoLock values to a byte slice.
func SAIsoLockListBytes(buf []byte, list []SAIsoLock) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

const (
	SAIsoLockFlagNoLock         = 1
	SAIsoLockFlagNoUnlock       = 2
	SAIsoLockFlagUseModMapMods  = 4
	SAIsoLockFlagGroupAbsolute  = 4
	SAIsoLockFlagISODfltIsGroup = 8
)

const (
	SAIsoLockNoAffectCtrls = 8
	SAIsoLockNoAffectPtr   = 16
	SAIsoLockNoAffectGroup = 32
	SAIsoLockNoAffectMods  = 64
)

type SALatchGroup SASetGroup

type SALatchMods SASetMods

type SALockControls SASetControls

type SALockDeviceBtn struct {
	Type  byte
	Flags byte
	// padding: 1 bytes
	Button byte
	Device byte
	// padding: 3 bytes
}

// SALockDeviceBtnRead reads a byte slice into a SALockDeviceBtn value.
func SALockDeviceBtnRead(buf []byte, v *SALockDeviceBtn) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	b += 1 // padding

	v.Button = buf[b]
	b += 1

	v.Device = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// SALockDeviceBtnReadList reads a byte slice into a list of SALockDeviceBtn values.
func SALockDeviceBtnReadList(buf []byte, dest []SALockDeviceBtn) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SALockDeviceBtn{}
		b += SALockDeviceBtnRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SALockDeviceBtn value to a byte slice.
func (v SALockDeviceBtn) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	b += 1 // padding

	buf[b] = v.Button
	b += 1

	buf[b] = v.Device
	b += 1

	b += 3 // padding

	return buf[:b]
}

// SALockDeviceBtnListBytes writes a list of SALockDeviceBtn values to a byte slice.
func SALockDeviceBtnListBytes(buf []byte, list []SALockDeviceBtn) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SALockGroup SASetGroup

type SALockMods SASetMods

type SALockPtrBtn struct {
	Type  byte
	Flags byte
	// padding: 1 bytes
	Button byte
	// padding: 4 bytes
}

// SALockPtrBtnRead reads a byte slice into a SALockPtrBtn value.
func SALockPtrBtnRead(buf []byte, v *SALockPtrBtn) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	b += 1 // padding

	v.Button = buf[b]
	b += 1

	b += 4 // padding

	return b
}

// SALockPtrBtnReadList reads a byte slice into a list of SALockPtrBtn values.
func SALockPtrBtnReadList(buf []byte, dest []SALockPtrBtn) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SALockPtrBtn{}
		b += SALockPtrBtnRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SALockPtrBtn value to a byte slice.
func (v SALockPtrBtn) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	b += 1 // padding

	buf[b] = v.Button
	b += 1

	b += 4 // padding

	return buf[:b]
}

// SALockPtrBtnListBytes writes a list of SALockPtrBtn values to a byte slice.
func SALockPtrBtnListBytes(buf []byte, list []SALockPtrBtn) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SAMovePtr struct {
	Type  byte
	Flags byte
	XHigh int8
	XLow  byte
	YHigh int8
	YLow  byte
	// padding: 2 bytes
}

// SAMovePtrRead reads a byte slice into a SAMovePtr value.
func SAMovePtrRead(buf []byte, v *SAMovePtr) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.XHigh = int8(buf[b])
	b += 1

	v.XLow = buf[b]
	b += 1

	v.YHigh = int8(buf[b])
	b += 1

	v.YLow = buf[b]
	b += 1

	b += 2 // padding

	return b
}

// SAMovePtrReadList reads a byte slice into a list of SAMovePtr values.
func SAMovePtrReadList(buf []byte, dest []SAMovePtr) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SAMovePtr{}
		b += SAMovePtrRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SAMovePtr value to a byte slice.
func (v SAMovePtr) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	buf[b] = byte(v.XHigh)
	b += 1

	buf[b] = v.XLow
	b += 1

	buf[b] = byte(v.YHigh)
	b += 1

	buf[b] = v.YLow
	b += 1

	b += 2 // padding

	return buf[:b]
}

// SAMovePtrListBytes writes a list of SAMovePtr values to a byte slice.
func SAMovePtrListBytes(buf []byte, list []SAMovePtr) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

const (
	SAMovePtrFlagNoAcceleration = 1
	SAMovePtrFlagMoveAbsoluteX  = 2
	SAMovePtrFlagMoveAbsoluteY  = 4
)

type SANoAction struct {
	Type byte
	// padding: 7 bytes
}

// SANoActionRead reads a byte slice into a SANoAction value.
func SANoActionRead(buf []byte, v *SANoAction) int {
	b := 0

	v.Type = buf[b]
	b += 1

	b += 7 // padding

	return b
}

// SANoActionReadList reads a byte slice into a list of SANoAction values.
func SANoActionReadList(buf []byte, dest []SANoAction) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SANoAction{}
		b += SANoActionRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SANoAction value to a byte slice.
func (v SANoAction) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	b += 7 // padding

	return buf[:b]
}

// SANoActionListBytes writes a list of SANoAction values to a byte slice.
func SANoActionListBytes(buf []byte, list []SANoAction) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SAPtrBtn struct {
	Type   byte
	Flags  byte
	Count  byte
	Button byte
	// padding: 4 bytes
}

// SAPtrBtnRead reads a byte slice into a SAPtrBtn value.
func SAPtrBtnRead(buf []byte, v *SAPtrBtn) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.Count = buf[b]
	b += 1

	v.Button = buf[b]
	b += 1

	b += 4 // padding

	return b
}

// SAPtrBtnReadList reads a byte slice into a list of SAPtrBtn values.
func SAPtrBtnReadList(buf []byte, dest []SAPtrBtn) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SAPtrBtn{}
		b += SAPtrBtnRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SAPtrBtn value to a byte slice.
func (v SAPtrBtn) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	buf[b] = v.Count
	b += 1

	buf[b] = v.Button
	b += 1

	b += 4 // padding

	return buf[:b]
}

// SAPtrBtnListBytes writes a list of SAPtrBtn values to a byte slice.
func SAPtrBtnListBytes(buf []byte, list []SAPtrBtn) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SARedirectKey struct {
	Type          byte
	Newkey        xproto.Keycode
	Mask          byte
	RealModifiers byte
	VmodsMaskHigh byte
	VmodsMaskLow  byte
	VmodsHigh     byte
	VmodsLow      byte
}

// SARedirectKeyRead reads a byte slice into a SARedirectKey value.
func SARedirectKeyRead(buf []byte, v *SARedirectKey) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Newkey = xproto.Keycode(buf[b])
	b += 1

	v.Mask = buf[b]
	b += 1

	v.RealModifiers = buf[b]
	b += 1

	v.VmodsMaskHigh = buf[b]
	b += 1

	v.VmodsMaskLow = buf[b]
	b += 1

	v.VmodsHigh = buf[b]
	b += 1

	v.VmodsLow = buf[b]
	b += 1

	return b
}

// SARedirectKeyReadList reads a byte slice into a list of SARedirectKey values.
func SARedirectKeyReadList(buf []byte, dest []SARedirectKey) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SARedirectKey{}
		b += SARedirectKeyRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SARedirectKey value to a byte slice.
func (v SARedirectKey) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = byte(v.Newkey)
	b += 1

	buf[b] = v.Mask
	b += 1

	buf[b] = v.RealModifiers
	b += 1

	buf[b] = v.VmodsMaskHigh
	b += 1

	buf[b] = v.VmodsMaskLow
	b += 1

	buf[b] = v.VmodsHigh
	b += 1

	buf[b] = v.VmodsLow
	b += 1

	return buf[:b]
}

// SARedirectKeyListBytes writes a list of SARedirectKey values to a byte slice.
func SARedirectKeyListBytes(buf []byte, list []SARedirectKey) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SASetControls struct {
	Type byte
	// padding: 3 bytes
	BoolCtrlsHigh byte
	BoolCtrlsLow  byte
	// padding: 2 bytes
}

// SASetControlsRead reads a byte slice into a SASetControls value.
func SASetControlsRead(buf []byte, v *SASetControls) int {
	b := 0

	v.Type = buf[b]
	b += 1

	b += 3 // padding

	v.BoolCtrlsHigh = buf[b]
	b += 1

	v.BoolCtrlsLow = buf[b]
	b += 1

	b += 2 // padding

	return b
}

// SASetControlsReadList reads a byte slice into a list of SASetControls values.
func SASetControlsReadList(buf []byte, dest []SASetControls) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SASetControls{}
		b += SASetControlsRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SASetControls value to a byte slice.
func (v SASetControls) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	b += 3 // padding

	buf[b] = v.BoolCtrlsHigh
	b += 1

	buf[b] = v.BoolCtrlsLow
	b += 1

	b += 2 // padding

	return buf[:b]
}

// SASetControlsListBytes writes a list of SASetControls values to a byte slice.
func SASetControlsListBytes(buf []byte, list []SASetControls) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SASetGroup struct {
	Type  byte
	Flags byte
	Group int8
	// padding: 5 bytes
}

// SASetGroupRead reads a byte slice into a SASetGroup value.
func SASetGroupRead(buf []byte, v *SASetGroup) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.Group = int8(buf[b])
	b += 1

	b += 5 // padding

	return b
}

// SASetGroupReadList reads a byte slice into a list of SASetGroup values.
func SASetGroupReadList(buf []byte, dest []SASetGroup) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SASetGroup{}
		b += SASetGroupRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SASetGroup value to a byte slice.
func (v SASetGroup) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	buf[b] = byte(v.Group)
	b += 1

	b += 5 // padding

	return buf[:b]
}

// SASetGroupListBytes writes a list of SASetGroup values to a byte slice.
func SASetGroupListBytes(buf []byte, list []SASetGroup) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SASetMods struct {
	Type      byte
	Flags     byte
	Mask      byte
	RealMods  byte
	VmodsHigh byte
	VmodsLow  byte
	// padding: 2 bytes
}

// SASetModsRead reads a byte slice into a SASetMods value.
func SASetModsRead(buf []byte, v *SASetMods) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.Mask = buf[b]
	b += 1

	v.RealMods = buf[b]
	b += 1

	v.VmodsHigh = buf[b]
	b += 1

	v.VmodsLow = buf[b]
	b += 1

	b += 2 // padding

	return b
}

// SASetModsReadList reads a byte slice into a list of SASetMods values.
func SASetModsReadList(buf []byte, dest []SASetMods) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SASetMods{}
		b += SASetModsRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SASetMods value to a byte slice.
func (v SASetMods) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	buf[b] = v.Mask
	b += 1

	buf[b] = v.RealMods
	b += 1

	buf[b] = v.VmodsHigh
	b += 1

	buf[b] = v.VmodsLow
	b += 1

	b += 2 // padding

	return buf[:b]
}

// SASetModsListBytes writes a list of SASetMods values to a byte slice.
func SASetModsListBytes(buf []byte, list []SASetMods) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SASetPtrDflt struct {
	Type   byte
	Flags  byte
	Affect byte
	Value  int8
	// padding: 4 bytes
}

// SASetPtrDfltRead reads a byte slice into a SASetPtrDflt value.
func SASetPtrDfltRead(buf []byte, v *SASetPtrDflt) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.Affect = buf[b]
	b += 1

	v.Value = int8(buf[b])
	b += 1

	b += 4 // padding

	return b
}

// SASetPtrDfltReadList reads a byte slice into a list of SASetPtrDflt values.
func SASetPtrDfltReadList(buf []byte, dest []SASetPtrDflt) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SASetPtrDflt{}
		b += SASetPtrDfltRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SASetPtrDflt value to a byte slice.
func (v SASetPtrDflt) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	buf[b] = v.Affect
	b += 1

	buf[b] = byte(v.Value)
	b += 1

	b += 4 // padding

	return buf[:b]
}

// SASetPtrDfltListBytes writes a list of SASetPtrDflt values to a byte slice.
func SASetPtrDfltListBytes(buf []byte, list []SASetPtrDflt) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

const (
	SASetPtrDfltFlagDfltBtnAbsolute  = 4
	SASetPtrDfltFlagAffectDfltButton = 1
)

type SASwitchScreen struct {
	Type      byte
	Flags     byte
	NewScreen int8
	// padding: 5 bytes
}

// SASwitchScreenRead reads a byte slice into a SASwitchScreen value.
func SASwitchScreenRead(buf []byte, v *SASwitchScreen) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.NewScreen = int8(buf[b])
	b += 1

	b += 5 // padding

	return b
}

// SASwitchScreenReadList reads a byte slice into a list of SASwitchScreen values.
func SASwitchScreenReadList(buf []byte, dest []SASwitchScreen) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SASwitchScreen{}
		b += SASwitchScreenRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SASwitchScreen value to a byte slice.
func (v SASwitchScreen) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	buf[b] = v.Flags
	b += 1

	buf[b] = byte(v.NewScreen)
	b += 1

	b += 5 // padding

	return buf[:b]
}

// SASwitchScreenListBytes writes a list of SASwitchScreen values to a byte slice.
func SASwitchScreenListBytes(buf []byte, list []SASwitchScreen) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SATerminate struct {
	Type byte
	// padding: 7 bytes
}

// SATerminateRead reads a byte slice into a SATerminate value.
func SATerminateRead(buf []byte, v *SATerminate) int {
	b := 0

	v.Type = buf[b]
	b += 1

	b += 7 // padding

	return b
}

// SATerminateReadList reads a byte slice into a list of SATerminate values.
func SATerminateReadList(buf []byte, dest []SATerminate) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SATerminate{}
		b += SATerminateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SATerminate value to a byte slice.
func (v SATerminate) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Type
	b += 1

	b += 7 // padding

	return buf[:b]
}

// SATerminateListBytes writes a list of SATerminate values to a byte slice.
func SATerminateListBytes(buf []byte, list []SATerminate) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

const (
	SATypeNoAction       = 0
	SATypeSetMods        = 1
	SATypeLatchMods      = 2
	SATypeLockMods       = 3
	SATypeSetGroup       = 4
	SATypeLatchGroup     = 5
	SATypeLockGroup      = 6
	SATypeMovePtr        = 7
	SATypePtrBtn         = 8
	SATypeLockPtrBtn     = 9
	SATypeSetPtrDflt     = 10
	SATypeISOLock        = 11
	SATypeTerminate      = 12
	SATypeSwitchScreen   = 13
	SATypeSetControls    = 14
	SATypeLockControls   = 15
	SATypeActionMessage  = 16
	SATypeRedirectKey    = 17
	SATypeDeviceBtn      = 18
	SATypeLockDeviceBtn  = 19
	SATypeDeviceValuator = 20
)

const (
	SAValWhatIgnoreVal      = 0
	SAValWhatSetValMin      = 1
	SAValWhatSetValCenter   = 2
	SAValWhatSetValMax      = 3
	SAValWhatSetValRelative = 4
	SAValWhatSetValAbsolute = 5
)

type SIAction struct {
	Type byte
	Data []byte // size: 8
}

// SIActionRead reads a byte slice into a SIAction value.
func SIActionRead(buf []byte, v *SIAction) int {
	b := 0

	v.Type = buf[b]
	b += 1

	v.Data = make([]byte, 7)
	copy(v.Data[:7], buf[b:])
	b += int(7)

	return b
}

// SIActionReadList reads a byte slice into a list of SIAction values.
func SIActionReadList(buf []byte, dest []SIAction) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SIAction{}
		b += SIActionRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SIAction value to a byte slice.
func (v SIAction) Bytes() []byte {
	buf := make([]byte, 9)
	b := 0

	buf[b] = v.Type
	b += 1

	copy(buf[b:], v.Data[:7])
	b += int(7)

	return buf[:b]
}

// SIActionListBytes writes a list of SIAction values to a byte slice.
func SIActionListBytes(buf []byte, list []SIAction) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// SIActionListSize computes the size (bytes) of a list of SIAction values.
func SIActionListSize(list []SIAction) int {
	size := 0
	for _ = range list {
		size += 9
	}
	return size
}

const (
	SaClearLocks    = 1
	SaLatchToLock   = 2
	SaUseModMapMods = 4
	SaGroupAbsolute = 4
)

type SetBehavior struct {
	Keycode  xproto.Keycode
	Behavior BehaviorUnion
	// padding: 1 bytes
}

// SetBehaviorRead reads a byte slice into a SetBehavior value.
func SetBehaviorRead(buf []byte, v *SetBehavior) int {
	b := 0

	v.Keycode = xproto.Keycode(buf[b])
	b += 1

	v.Behavior = BehaviorUnion{}
	b += BehaviorUnionRead(buf[b:], &v.Behavior)

	b += 1 // padding

	return b
}

// SetBehaviorReadList reads a byte slice into a list of SetBehavior values.
func SetBehaviorReadList(buf []byte, dest []SetBehavior) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SetBehavior{}
		b += SetBehaviorRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SetBehavior value to a byte slice.
func (v SetBehavior) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = byte(v.Keycode)
	b += 1

	{
		unionBytes := v.Behavior.Bytes()
		copy(buf[b:], unionBytes)
		b += len(unionBytes)
	}

	b += 1 // padding

	return buf[:b]
}

// SetBehaviorListBytes writes a list of SetBehavior values to a byte slice.
func SetBehaviorListBytes(buf []byte, list []SetBehavior) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SetExplicit struct {
	Keycode  xproto.Keycode
	Explicit byte
}

// SetExplicitRead reads a byte slice into a SetExplicit value.
func SetExplicitRead(buf []byte, v *SetExplicit) int {
	b := 0

	v.Keycode = xproto.Keycode(buf[b])
	b += 1

	v.Explicit = buf[b]
	b += 1

	return b
}

// SetExplicitReadList reads a byte slice into a list of SetExplicit values.
func SetExplicitReadList(buf []byte, dest []SetExplicit) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SetExplicit{}
		b += SetExplicitRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SetExplicit value to a byte slice.
func (v SetExplicit) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = byte(v.Keycode)
	b += 1

	buf[b] = v.Explicit
	b += 1

	return buf[:b]
}

// SetExplicitListBytes writes a list of SetExplicit values to a byte slice.
func SetExplicitListBytes(buf []byte, list []SetExplicit) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

type SetKeyType struct {
	Mask        byte
	RealMods    byte
	VirtualMods uint16
	NumLevels   byte
	NMapEntries byte
	Preserve    bool
	// padding: 1 bytes
	Entries         []KTSetMapEntry // size: xgb.Pad((int(NMapEntries) * 4))
	PreserveEntries []KTSetMapEntry // size: xgb.Pad(((int(Preserve) * int(NMapEntries)) * 4))
}

// SetKeyTypeRead reads a byte slice into a SetKeyType value.
func SetKeyTypeRead(buf []byte, v *SetKeyType) int {
	b := 0

	v.Mask = buf[b]
	b += 1

	v.RealMods = buf[b]
	b += 1

	v.VirtualMods = xgb.Get16(buf[b:])
	b += 2

	v.NumLevels = buf[b]
	b += 1

	v.NMapEntries = buf[b]
	b += 1

	if buf[b] == 1 {
		v.Preserve = true
	} else {
		v.Preserve = false
	}
	b += 1

	b += 1 // padding

	v.Entries = make([]KTSetMapEntry, v.NMapEntries)
	b += KTSetMapEntryReadList(buf[b:], v.Entries)

	v.PreserveEntries = make([]KTSetMapEntry, (int(v.Preserve) * int(v.NMapEntries)))
	b += KTSetMapEntryReadList(buf[b:], v.PreserveEntries)

	return b
}

// SetKeyTypeReadList reads a byte slice into a list of SetKeyType values.
func SetKeyTypeReadList(buf []byte, dest []SetKeyType) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SetKeyType{}
		b += SetKeyTypeRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SetKeyType value to a byte slice.
func (v SetKeyType) Bytes() []byte {
	buf := make([]byte, ((8 + xgb.Pad((int(v.NMapEntries) * 4))) + xgb.Pad(((int(v.Preserve) * int(v.NMapEntries)) * 4))))
	b := 0

	buf[b] = v.Mask
	b += 1

	buf[b] = v.RealMods
	b += 1

	xgb.Put16(buf[b:], v.VirtualMods)
	b += 2

	buf[b] = v.NumLevels
	b += 1

	buf[b] = v.NMapEntries
	b += 1

	if v.Preserve {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	b += KTSetMapEntryListBytes(buf[b:], v.Entries)

	b += KTSetMapEntryListBytes(buf[b:], v.PreserveEntries)

	return buf[:b]
}

// SetKeyTypeListBytes writes a list of SetKeyType values to a byte slice.
func SetKeyTypeListBytes(buf []byte, list []SetKeyType) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// SetKeyTypeListSize computes the size (bytes) of a list of SetKeyType values.
func SetKeyTypeListSize(list []SetKeyType) int {
	size := 0
	for _, item := range list {
		size += ((8 + xgb.Pad((int(item.NMapEntries) * 4))) + xgb.Pad(((int(item.Preserve) * int(item.NMapEntries)) * 4)))
	}
	return size
}

const (
	SetMapFlagsResizeTypes      = 1
	SetMapFlagsRecomputeActions = 2
)

const (
	SetOfGroupGroup1 = 1
	SetOfGroupGroup2 = 2
	SetOfGroupGroup3 = 4
	SetOfGroupGroup4 = 8
)

const (
	SetOfGroupsAny = 128
)

type Shape struct {
	Name       xproto.Atom
	NOutlines  byte
	PrimaryNdx byte
	ApproxNdx  byte
	// padding: 1 bytes
	Outlines []Outline // size: OutlineListSize(Outlines)
}

// ShapeRead reads a byte slice into a Shape value.
func ShapeRead(buf []byte, v *Shape) int {
	b := 0

	v.Name = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.NOutlines = buf[b]
	b += 1

	v.PrimaryNdx = buf[b]
	b += 1

	v.ApproxNdx = buf[b]
	b += 1

	b += 1 // padding

	v.Outlines = make([]Outline, v.NOutlines)
	b += OutlineReadList(buf[b:], v.Outlines)

	return b
}

// ShapeReadList reads a byte slice into a list of Shape values.
func ShapeReadList(buf []byte, dest []Shape) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Shape{}
		b += ShapeRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Shape value to a byte slice.
func (v Shape) Bytes() []byte {
	buf := make([]byte, (8 + OutlineListSize(v.Outlines)))
	b := 0

	xgb.Put32(buf[b:], uint32(v.Name))
	b += 4

	buf[b] = v.NOutlines
	b += 1

	buf[b] = v.PrimaryNdx
	b += 1

	buf[b] = v.ApproxNdx
	b += 1

	b += 1 // padding

	b += OutlineListBytes(buf[b:], v.Outlines)

	return buf[:b]
}

// ShapeListBytes writes a list of Shape values to a byte slice.
func ShapeListBytes(buf []byte, list []Shape) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

// ShapeListSize computes the size (bytes) of a list of Shape values.
func ShapeListSize(list []Shape) int {
	size := 0
	for _, item := range list {
		size += (8 + OutlineListSize(item.Outlines))
	}
	return size
}

// StateNotify is the event number for a StateNotifyEvent.
const StateNotify = 2

type StateNotifyEvent struct {
	Sequence          uint16
	XkbType           byte
	Time              xproto.Timestamp
	DeviceID          byte
	Mods              byte
	BaseMods          byte
	LatchedMods       byte
	LockedMods        byte
	Group             byte
	BaseGroup         int16
	LatchedGroup      int16
	LockedGroup       byte
	CompatState       byte
	GrabMods          byte
	CompatGrabMods    byte
	LookupMods        byte
	CompatLoockupMods byte
	PtrBtnState       uint16
	Changed           uint16
	Keycode           xproto.Keycode
	EventType         byte
	RequestMajor      byte
	RequestMinor      byte
}

// StateNotifyEventNew constructs a StateNotifyEvent value that implements xgb.Event from a byte slice.
func StateNotifyEventNew(buf []byte) xgb.Event {
	v := StateNotifyEvent{}
	b := 1 // don't read event number

	v.XkbType = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceID = buf[b]
	b += 1

	v.Mods = buf[b]
	b += 1

	v.BaseMods = buf[b]
	b += 1

	v.LatchedMods = buf[b]
	b += 1

	v.LockedMods = buf[b]
	b += 1

	v.Group = buf[b]
	b += 1

	v.BaseGroup = int16(xgb.Get16(buf[b:]))
	b += 2

	v.LatchedGroup = int16(xgb.Get16(buf[b:]))
	b += 2

	v.LockedGroup = buf[b]
	b += 1

	v.CompatState = buf[b]
	b += 1

	v.GrabMods = buf[b]
	b += 1

	v.CompatGrabMods = buf[b]
	b += 1

	v.LookupMods = buf[b]
	b += 1

	v.CompatLoockupMods = buf[b]
	b += 1

	v.PtrBtnState = xgb.Get16(buf[b:])
	b += 2

	v.Changed = xgb.Get16(buf[b:])
	b += 2

	v.Keycode = xproto.Keycode(buf[b])
	b += 1

	v.EventType = buf[b]
	b += 1

	v.RequestMajor = buf[b]
	b += 1

	v.RequestMinor = buf[b]
	b += 1

	return v
}

// Bytes writes a StateNotifyEvent value to a byte slice.
func (v StateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 2
	b += 1

	buf[b] = v.XkbType
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.DeviceID
	b += 1

	buf[b] = v.Mods
	b += 1

	buf[b] = v.BaseMods
	b += 1

	buf[b] = v.LatchedMods
	b += 1

	buf[b] = v.LockedMods
	b += 1

	buf[b] = v.Group
	b += 1

	xgb.Put16(buf[b:], uint16(v.BaseGroup))
	b += 2

	xgb.Put16(buf[b:], uint16(v.LatchedGroup))
	b += 2

	buf[b] = v.LockedGroup
	b += 1

	buf[b] = v.CompatState
	b += 1

	buf[b] = v.GrabMods
	b += 1

	buf[b] = v.CompatGrabMods
	b += 1

	buf[b] = v.LookupMods
	b += 1

	buf[b] = v.CompatLoockupMods
	b += 1

	xgb.Put16(buf[b:], v.PtrBtnState)
	b += 2

	xgb.Put16(buf[b:], v.Changed)
	b += 2

	buf[b] = byte(v.Keycode)
	b += 1

	buf[b] = v.EventType
	b += 1

	buf[b] = v.RequestMajor
	b += 1

	buf[b] = v.RequestMinor
	b += 1

	return buf
}

// SequenceId returns the sequence id attached to the StateNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v StateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of StateNotifyEvent.
func (v StateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 22)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("XkbType: %d", v.XkbType))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceID: %d", v.DeviceID))
	fieldVals = append(fieldVals, xgb.Sprintf("Mods: %d", v.Mods))
	fieldVals = append(fieldVals, xgb.Sprintf("BaseMods: %d", v.BaseMods))
	fieldVals = append(fieldVals, xgb.Sprintf("LatchedMods: %d", v.LatchedMods))
	fieldVals = append(fieldVals, xgb.Sprintf("LockedMods: %d", v.LockedMods))
	fieldVals = append(fieldVals, xgb.Sprintf("Group: %d", v.Group))
	fieldVals = append(fieldVals, xgb.Sprintf("BaseGroup: %d", v.BaseGroup))
	fieldVals = append(fieldVals, xgb.Sprintf("LatchedGroup: %d", v.LatchedGroup))
	fieldVals = append(fieldVals, xgb.Sprintf("LockedGroup: %d", v.LockedGroup))
	fieldVals = append(fieldVals, xgb.Sprintf("CompatState: %d", v.CompatState))
	fieldVals = append(fieldVals, xgb.Sprintf("GrabMods: %d", v.GrabMods))
	fieldVals = append(fieldVals, xgb.Sprintf("CompatGrabMods: %d", v.CompatGrabMods))
	fieldVals = append(fieldVals, xgb.Sprintf("LookupMods: %d", v.LookupMods))
	fieldVals = append(fieldVals, xgb.Sprintf("CompatLoockupMods: %d", v.CompatLoockupMods))
	fieldVals = append(fieldVals, xgb.Sprintf("PtrBtnState: %d", v.PtrBtnState))
	fieldVals = append(fieldVals, xgb.Sprintf("Changed: %d", v.Changed))
	fieldVals = append(fieldVals, xgb.Sprintf("Keycode: %d", v.Keycode))
	fieldVals = append(fieldVals, xgb.Sprintf("EventType: %d", v.EventType))
	fieldVals = append(fieldVals, xgb.Sprintf("RequestMajor: %d", v.RequestMajor))
	fieldVals = append(fieldVals, xgb.Sprintf("RequestMinor: %d", v.RequestMinor))
	return "StateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XKEYBOARD"][2] = StateNotifyEventNew
}

const (
	StatePartModifierState    = 1
	StatePartModifierBase     = 2
	StatePartModifierLatch    = 4
	StatePartModifierLock     = 8
	StatePartGroupState       = 16
	StatePartGroupBase        = 32
	StatePartGroupLatch       = 64
	StatePartGroupLock        = 128
	StatePartCompatState      = 256
	StatePartGrabMods         = 512
	StatePartCompatGrabMods   = 1024
	StatePartLookupMods       = 2048
	StatePartCompatLookupMods = 4096
	StatePartPointerButtons   = 8192
)

type String8 byte

const (
	SwitchScreenFlagApplication = 1
	SwitchScreenFlagAbsolute    = 4
)

const (
	SymInterpMatchLevelOneOnly = 128
	SymInterpMatchOpMask       = 127
)

type SymInterpret struct {
	Sym        xproto.Keysym
	Mods       byte
	Match      byte
	VirtualMod byte
	Flags      byte
	Action     SIAction
}

// SymInterpretRead reads a byte slice into a SymInterpret value.
func SymInterpretRead(buf []byte, v *SymInterpret) int {
	b := 0

	v.Sym = xproto.Keysym(xgb.Get32(buf[b:]))
	b += 4

	v.Mods = buf[b]
	b += 1

	v.Match = buf[b]
	b += 1

	v.VirtualMod = buf[b]
	b += 1

	v.Flags = buf[b]
	b += 1

	v.Action = SIAction{}
	b += SIActionRead(buf[b:], &v.Action)

	return b
}

// SymInterpretReadList reads a byte slice into a list of SymInterpret values.
func SymInterpretReadList(buf []byte, dest []SymInterpret) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SymInterpret{}
		b += SymInterpretRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a SymInterpret value to a byte slice.
func (v SymInterpret) Bytes() []byte {
	buf := make([]byte, 17)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Sym))
	b += 4

	buf[b] = v.Mods
	b += 1

	buf[b] = v.Match
	b += 1

	buf[b] = v.VirtualMod
	b += 1

	buf[b] = v.Flags
	b += 1

	{
		structBytes := v.Action.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}

	return buf[:b]
}

// SymInterpretListBytes writes a list of SymInterpret values to a byte slice.
func SymInterpretListBytes(buf []byte, list []SymInterpret) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += len(structBytes)
	}
	return xgb.Pad(b)
}

const (
	SymInterpretMatchNoneOf      = 0
	SymInterpretMatchAnyOfOrNone = 1
	SymInterpretMatchAnyOf       = 2
	SymInterpretMatchAllOf       = 3
	SymInterpretMatchExactly     = 4
)

const (
	VMod15 = 32768
	VMod14 = 16384
	VMod13 = 8192
	VMod12 = 4096
	VMod11 = 2048
	VMod10 = 1024
	VMod9  = 512
	VMod8  = 256
	VMod7  = 128
	VMod6  = 64
	VMod5  = 32
	VMod4  = 16
	VMod3  = 8
	VMod2  = 4
	VMod1  = 2
	VMod0  = 1
)

const (
	VModsHigh15 = 128
	VModsHigh14 = 64
	VModsHigh13 = 32
	VModsHigh12 = 16
	VModsHigh11 = 8
	VModsHigh10 = 4
	VModsHigh9  = 2
	VModsHigh8  = 1
)

const (
	VModsLow7 = 128
	VModsLow6 = 64
	VModsLow5 = 32
	VModsLow4 = 16
	VModsLow3 = 8
	VModsLow2 = 4
	VModsLow1 = 2
	VModsLow0 = 1
)

const (
	XIFeatureKeyboards      = 1
	XIFeatureButtonActions  = 2
	XIFeatureIndicatorNames = 4
	XIFeatureIndicatorMaps  = 8
	XIFeatureIndicatorState = 16
)

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Card32'

// BellCookie is a cookie used only for Bell requests.
type BellCookie struct {
	*xgb.Cookie
}

// Bell sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func Bell(c *xgb.Conn, DeviceSpec DeviceSpec, BellClass BellClassSpec, BellID IDSpec, Percent int8, ForceSound bool, EventOnly bool, Pitch int16, Duration int16, Name xproto.Atom, Window xproto.Window) BellCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'Bell' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(bellRequest(c, DeviceSpec, BellClass, BellID, Percent, ForceSound, EventOnly, Pitch, Duration, Name, Window), cookie)
	return BellCookie{cookie}
}

// BellChecked sends a checked request.
// If an error occurs, it can be retrieved using BellCookie.Check()
func BellChecked(c *xgb.Conn, DeviceSpec DeviceSpec, BellClass BellClassSpec, BellID IDSpec, Percent int8, ForceSound bool, EventOnly bool, Pitch int16, Duration int16, Name xproto.Atom, Window xproto.Window) BellCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'Bell' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(bellRequest(c, DeviceSpec, BellClass, BellID, Percent, ForceSound, EventOnly, Pitch, Duration, Name, Window), cookie)
	return BellCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook BellCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Bell
// bellRequest writes a Bell request to a byte slice.
func bellRequest(c *xgb.Conn, DeviceSpec DeviceSpec, BellClass BellClassSpec, BellID IDSpec, Percent int8, ForceSound bool, EventOnly bool, Pitch int16, Duration int16, Name xproto.Atom, Window xproto.Window) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], uint16(BellClass))
	b += 2

	xgb.Put16(buf[b:], uint16(BellID))
	b += 2

	buf[b] = byte(Percent)
	b += 1

	if ForceSound {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if EventOnly {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(Pitch))
	b += 2

	xgb.Put16(buf[b:], uint16(Duration))
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], uint32(Name))
	b += 4

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// GetCompatMapCookie is a cookie used only for GetCompatMap requests.
type GetCompatMapCookie struct {
	*xgb.Cookie
}

// GetCompatMap sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetCompatMapCookie.Reply()
func GetCompatMap(c *xgb.Conn, DeviceSpec DeviceSpec, Groups byte, GetAllSI bool, FirstSI uint16, NSI uint16) GetCompatMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetCompatMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getCompatMapRequest(c, DeviceSpec, Groups, GetAllSI, FirstSI, NSI), cookie)
	return GetCompatMapCookie{cookie}
}

// GetCompatMapUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetCompatMapUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, Groups byte, GetAllSI bool, FirstSI uint16, NSI uint16) GetCompatMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetCompatMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getCompatMapRequest(c, DeviceSpec, Groups, GetAllSI, FirstSI, NSI), cookie)
	return GetCompatMapCookie{cookie}
}

// GetCompatMapReply represents the data returned from a GetCompatMap request.
type GetCompatMapReply struct {
	Sequence   uint16 // sequence number of the request for this reply
	Length     uint32 // number of bytes in this reply
	DeviceID   byte
	GroupsRtrn byte
	// padding: 1 bytes
	FirstSIRtrn uint16
	NSIRtrn     uint16
	NTotalSI    uint16
	// padding: 16 bytes
	SiRtrn    []SymInterpret // size: xgb.Pad((int(NSIRtrn) * 17))
	GroupRtrn []ModDef       // size: xgb.Pad((xgb.PopCount(GroupsRtrn) * 4))
}

// Reply blocks and returns the reply data for a GetCompatMap request.
func (cook GetCompatMapCookie) Reply() (*GetCompatMapReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getCompatMapReply(buf), nil
}

// getCompatMapReply reads a byte slice into a GetCompatMapReply value.
func getCompatMapReply(buf []byte) *GetCompatMapReply {
	v := new(GetCompatMapReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.GroupsRtrn = buf[b]
	b += 1

	b += 1 // padding

	v.FirstSIRtrn = xgb.Get16(buf[b:])
	b += 2

	v.NSIRtrn = xgb.Get16(buf[b:])
	b += 2

	v.NTotalSI = xgb.Get16(buf[b:])
	b += 2

	b += 16 // padding

	v.SiRtrn = make([]SymInterpret, v.NSIRtrn)
	b += SymInterpretReadList(buf[b:], v.SiRtrn)

	v.GroupRtrn = make([]ModDef, xgb.PopCount(v.GroupsRtrn))
	b += ModDefReadList(buf[b:], v.GroupRtrn)

	return v
}

// Write request to wire for GetCompatMap
// getCompatMapRequest writes a GetCompatMap request to a byte slice.
func getCompatMapRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Groups byte, GetAllSI bool, FirstSI uint16, NSI uint16) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	buf[b] = Groups
	b += 1

	if GetAllSI {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], FirstSI)
	b += 2

	xgb.Put16(buf[b:], NSI)
	b += 2

	return buf
}

// GetControlsCookie is a cookie used only for GetControls requests.
type GetControlsCookie struct {
	*xgb.Cookie
}

// GetControls sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetControlsCookie.Reply()
func GetControls(c *xgb.Conn, DeviceSpec DeviceSpec) GetControlsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetControls' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getControlsRequest(c, DeviceSpec), cookie)
	return GetControlsCookie{cookie}
}

// GetControlsUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetControlsUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec) GetControlsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetControls' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getControlsRequest(c, DeviceSpec), cookie)
	return GetControlsCookie{cookie}
}

// GetControlsReply represents the data returned from a GetControls request.
type GetControlsReply struct {
	Sequence               uint16 // sequence number of the request for this reply
	Length                 uint32 // number of bytes in this reply
	DeviceID               byte
	MouseKeysDfltBtn       byte
	NumGroups              byte
	GroupsWrap             byte
	InternalModsMask       byte
	IgnoreLockModsMask     byte
	InternalModsRealMods   byte
	IgnoreLockModsRealMods byte
	// padding: 1 bytes
	InternalModsVmods           uint16
	IgnoreLockModsVmods         uint16
	RepeatDelay                 uint16
	RepeatInterval              uint16
	SlowKeysDelay               uint16
	DebounceDelay               uint16
	MouseKeysDelay              uint16
	MouseKeysInterval           uint16
	MouseKeysTimeToMax          uint16
	MouseKeysMaxSpeed           uint16
	MouseKeysCurve              int16
	AccessXOption               uint16
	AccessXTimeout              uint16
	AccessXTimeoutOptionsMask   uint16
	AccessXTimeoutOptionsValues uint16
	// padding: 2 bytes
	AccessXTimeoutMask   uint32
	AccessXTimeoutValues uint32
	EnabledControls      uint32
	PerKeyRepeat         []byte // size: 32
}

// Reply blocks and returns the reply data for a GetControls request.
func (cook GetControlsCookie) Reply() (*GetControlsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getControlsReply(buf), nil
}

// getControlsReply reads a byte slice into a GetControlsReply value.
func getControlsReply(buf []byte) *GetControlsReply {
	v := new(GetControlsReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MouseKeysDfltBtn = buf[b]
	b += 1

	v.NumGroups = buf[b]
	b += 1

	v.GroupsWrap = buf[b]
	b += 1

	v.InternalModsMask = buf[b]
	b += 1

	v.IgnoreLockModsMask = buf[b]
	b += 1

	v.InternalModsRealMods = buf[b]
	b += 1

	v.IgnoreLockModsRealMods = buf[b]
	b += 1

	b += 1 // padding

	v.InternalModsVmods = xgb.Get16(buf[b:])
	b += 2

	v.IgnoreLockModsVmods = xgb.Get16(buf[b:])
	b += 2

	v.RepeatDelay = xgb.Get16(buf[b:])
	b += 2

	v.RepeatInterval = xgb.Get16(buf[b:])
	b += 2

	v.SlowKeysDelay = xgb.Get16(buf[b:])
	b += 2

	v.DebounceDelay = xgb.Get16(buf[b:])
	b += 2

	v.MouseKeysDelay = xgb.Get16(buf[b:])
	b += 2

	v.MouseKeysInterval = xgb.Get16(buf[b:])
	b += 2

	v.MouseKeysTimeToMax = xgb.Get16(buf[b:])
	b += 2

	v.MouseKeysMaxSpeed = xgb.Get16(buf[b:])
	b += 2

	v.MouseKeysCurve = int16(xgb.Get16(buf[b:]))
	b += 2

	v.AccessXOption = xgb.Get16(buf[b:])
	b += 2

	v.AccessXTimeout = xgb.Get16(buf[b:])
	b += 2

	v.AccessXTimeoutOptionsMask = xgb.Get16(buf[b:])
	b += 2

	v.AccessXTimeoutOptionsValues = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.AccessXTimeoutMask = xgb.Get32(buf[b:])
	b += 4

	v.AccessXTimeoutValues = xgb.Get32(buf[b:])
	b += 4

	v.EnabledControls = xgb.Get32(buf[b:])
	b += 4

	v.PerKeyRepeat = make([]byte, 32)
	copy(v.PerKeyRepeat[:32], buf[b:])
	b += int(32)

	return v
}

// Write request to wire for GetControls
// getControlsRequest writes a GetControls request to a byte slice.
func getControlsRequest(c *xgb.Conn, DeviceSpec DeviceSpec) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	b += 2 // padding

	return buf
}

// GetDeviceInfoCookie is a cookie used only for GetDeviceInfo requests.
type GetDeviceInfoCookie struct {
	*xgb.Cookie
}

// GetDeviceInfo sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetDeviceInfoCookie.Reply()
func GetDeviceInfo(c *xgb.Conn, DeviceSpec DeviceSpec, Wanted uint16, AllButtons bool, FirstButton byte, NButtons byte, LedClass LedClassSpec, LedID IDSpec) GetDeviceInfoCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetDeviceInfo' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceInfoRequest(c, DeviceSpec, Wanted, AllButtons, FirstButton, NButtons, LedClass, LedID), cookie)
	return GetDeviceInfoCookie{cookie}
}

// GetDeviceInfoUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetDeviceInfoUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, Wanted uint16, AllButtons bool, FirstButton byte, NButtons byte, LedClass LedClassSpec, LedID IDSpec) GetDeviceInfoCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetDeviceInfo' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceInfoRequest(c, DeviceSpec, Wanted, AllButtons, FirstButton, NButtons, LedClass, LedID), cookie)
	return GetDeviceInfoCookie{cookie}
}

// GetDeviceInfoReply represents the data returned from a GetDeviceInfo request.
type GetDeviceInfoReply struct {
	Sequence       uint16 // sequence number of the request for this reply
	Length         uint32 // number of bytes in this reply
	DeviceID       byte
	Present        uint16
	Supported      uint16
	Unsupported    uint16
	NDeviceLedFBs  uint16
	FirstBtnWanted byte
	NBtnsWanted    byte
	FirstBtnRtrn   byte
	NBtnsRtrn      byte
	TotalBtns      byte
	HasOwnState    bool
	DfltKbdFB      uint16
	DfltLedFB      uint16
	// padding: 2 bytes
	DevType xproto.Atom
	NameLen uint16
	Name    []String8 // size: xgb.Pad((int(NameLen) * 1))
	// alignment gap to multiple of 4
	BtnActions []ActionUnion   // size: xgb.Pad((int(NBtnsRtrn) * 8))
	Leds       []DeviceLedInfo // size: DeviceLedInfoListSize(Leds)
}

// Reply blocks and returns the reply data for a GetDeviceInfo request.
func (cook GetDeviceInfoCookie) Reply() (*GetDeviceInfoReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceInfoReply(buf), nil
}

// getDeviceInfoReply reads a byte slice into a GetDeviceInfoReply value.
func getDeviceInfoReply(buf []byte) *GetDeviceInfoReply {
	v := new(GetDeviceInfoReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Present = xgb.Get16(buf[b:])
	b += 2

	v.Supported = xgb.Get16(buf[b:])
	b += 2

	v.Unsupported = xgb.Get16(buf[b:])
	b += 2

	v.NDeviceLedFBs = xgb.Get16(buf[b:])
	b += 2

	v.FirstBtnWanted = buf[b]
	b += 1

	v.NBtnsWanted = buf[b]
	b += 1

	v.FirstBtnRtrn = buf[b]
	b += 1

	v.NBtnsRtrn = buf[b]
	b += 1

	v.TotalBtns = buf[b]
	b += 1

	if buf[b] == 1 {
		v.HasOwnState = true
	} else {
		v.HasOwnState = false
	}
	b += 1

	v.DfltKbdFB = xgb.Get16(buf[b:])
	b += 2

	v.DfltLedFB = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.DevType = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.NameLen = xgb.Get16(buf[b:])
	b += 2

	v.Name = make([]String8, v.NameLen)
	for i := 0; i < int(v.NameLen); i++ {
		v.Name[i] = String8(buf[b])
		b += 1
	}

	b = (b + 3) & ^3 // alignment gap

	v.BtnActions = make([]ActionUnion, v.NBtnsRtrn)
	b += ActionUnionReadList(buf[b:], v.BtnActions)

	v.Leds = make([]DeviceLedInfo, v.NDeviceLedFBs)
	b += DeviceLedInfoReadList(buf[b:], v.Leds)

	return v
}

// Write request to wire for GetDeviceInfo
// getDeviceInfoRequest writes a GetDeviceInfo request to a byte slice.
func getDeviceInfoRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Wanted uint16, AllButtons bool, FirstButton byte, NButtons byte, LedClass LedClassSpec, LedID IDSpec) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 24 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], Wanted)
	b += 2

	if AllButtons {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = FirstButton
	b += 1

	buf[b] = NButtons
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(LedClass))
	b += 2

	xgb.Put16(buf[b:], uint16(LedID))
	b += 2

	return buf
}

// GetIndicatorMapCookie is a cookie used only for GetIndicatorMap requests.
type GetIndicatorMapCookie struct {
	*xgb.Cookie
}

// GetIndicatorMap sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetIndicatorMapCookie.Reply()
func GetIndicatorMap(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32) GetIndicatorMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetIndicatorMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getIndicatorMapRequest(c, DeviceSpec, Which), cookie)
	return GetIndicatorMapCookie{cookie}
}

// GetIndicatorMapUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetIndicatorMapUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32) GetIndicatorMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetIndicatorMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getIndicatorMapRequest(c, DeviceSpec, Which), cookie)
	return GetIndicatorMapCookie{cookie}
}

// GetIndicatorMapReply represents the data returned from a GetIndicatorMap request.
type GetIndicatorMapReply struct {
	Sequence       uint16 // sequence number of the request for this reply
	Length         uint32 // number of bytes in this reply
	DeviceID       byte
	Which          uint32
	RealIndicators uint32
	NIndicators    byte
	// padding: 15 bytes
	Maps []IndicatorMap // size: xgb.Pad((xgb.PopCount(Which) * 12))
}

// Reply blocks and returns the reply data for a GetIndicatorMap request.
func (cook GetIndicatorMapCookie) Reply() (*GetIndicatorMapReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getIndicatorMapReply(buf), nil
}

// getIndicatorMapReply reads a byte slice into a GetIndicatorMapReply value.
func getIndicatorMapReply(buf []byte) *GetIndicatorMapReply {
	v := new(GetIndicatorMapReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Which = xgb.Get32(buf[b:])
	b += 4

	v.RealIndicators = xgb.Get32(buf[b:])
	b += 4

	v.NIndicators = buf[b]
	b += 1

	b += 15 // padding

	v.Maps = make([]IndicatorMap, xgb.PopCount(v.Which))
	b += IndicatorMapReadList(buf[b:], v.Maps)

	return v
}

// Write request to wire for GetIndicatorMap
// getIndicatorMapRequest writes a GetIndicatorMap request to a byte slice.
func getIndicatorMapRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], Which)
	b += 4

	return buf
}

// GetIndicatorStateCookie is a cookie used only for GetIndicatorState requests.
type GetIndicatorStateCookie struct {
	*xgb.Cookie
}

// GetIndicatorState sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetIndicatorStateCookie.Reply()
func GetIndicatorState(c *xgb.Conn, DeviceSpec DeviceSpec) GetIndicatorStateCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetIndicatorState' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getIndicatorStateRequest(c, DeviceSpec), cookie)
	return GetIndicatorStateCookie{cookie}
}

// GetIndicatorStateUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetIndicatorStateUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec) GetIndicatorStateCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetIndicatorState' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getIndicatorStateRequest(c, DeviceSpec), cookie)
	return GetIndicatorStateCookie{cookie}
}

// GetIndicatorStateReply represents the data returned from a GetIndicatorState request.
type GetIndicatorStateReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	DeviceID byte
	State    uint32
	// padding: 20 bytes
}

// Reply blocks and returns the reply data for a GetIndicatorState request.
func (cook GetIndicatorStateCookie) Reply() (*GetIndicatorStateReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getIndicatorStateReply(buf), nil
}

// getIndicatorStateReply reads a byte slice into a GetIndicatorStateReply value.
func getIndicatorStateReply(buf []byte) *GetIndicatorStateReply {
	v := new(GetIndicatorStateReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.State = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	return v
}

// Write request to wire for GetIndicatorState
// getIndicatorStateRequest writes a GetIndicatorState request to a byte slice.
func getIndicatorStateRequest(c *xgb.Conn, DeviceSpec DeviceSpec) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	b += 2 // padding

	return buf
}

// GetKbdByNameCookie is a cookie used only for GetKbdByName requests.
type GetKbdByNameCookie struct {
	*xgb.Cookie
}

// GetKbdByName sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetKbdByNameCookie.Reply()
func GetKbdByName(c *xgb.Conn, DeviceSpec DeviceSpec, Need uint16, Want uint16, Load bool) GetKbdByNameCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetKbdByName' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getKbdByNameRequest(c, DeviceSpec, Need, Want, Load), cookie)
	return GetKbdByNameCookie{cookie}
}

// GetKbdByNameUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetKbdByNameUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, Need uint16, Want uint16, Load bool) GetKbdByNameCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetKbdByName' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getKbdByNameRequest(c, DeviceSpec, Need, Want, Load), cookie)
	return GetKbdByNameCookie{cookie}
}

// GetKbdByNameReply represents the data returned from a GetKbdByName request.
type GetKbdByNameReply struct {
	Sequence    uint16 // sequence number of the request for this reply
	Length      uint32 // number of bytes in this reply
	DeviceID    byte
	MinKeyCode  xproto.Keycode
	MaxKeyCode  xproto.Keycode
	Loaded      bool
	NewKeyboard bool
	Found       uint16
	Reported    uint16
	// padding: 16 bytes
	Replies []uint32
}

// Reply blocks and returns the reply data for a GetKbdByName request.
func (cook GetKbdByNameCookie) Reply() (*GetKbdByNameReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getKbdByNameReply(buf), nil
}

// getKbdByNameReply reads a byte slice into a GetKbdByNameReply value.
func getKbdByNameReply(buf []byte) *GetKbdByNameReply {
	v := new(GetKbdByNameReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MinKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.MaxKeyCode = xproto.Keycode(buf[b])
	b += 1

	if buf[b] == 1 {
		v.Loaded = true
	} else {
		v.Loaded = false
	}
	b += 1

	if buf[b] == 1 {
		v.NewKeyboard = true
	} else {
		v.NewKeyboard = false
	}
	b += 1

	v.Found = xgb.Get16(buf[b:])
	b += 2

	v.Reported = xgb.Get16(buf[b:])
	b += 2

	b += 16 // padding

	v.Replies = make([]uint32, xgb.PopCount(int(v.Reported)))
	for i := 0; i < xgb.PopCount(int(v.Reported)); i++ {
		v.Replies[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetKbdByName
// getKbdByNameRequest writes a GetKbdByName request to a byte slice.
func getKbdByNameRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Need uint16, Want uint16, Load bool) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 23 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], Need)
	b += 2

	xgb.Put16(buf[b:], Want)
	b += 2

	if Load {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	return buf
}

// GetMapCookie is a cookie used only for GetMap requests.
type GetMapCookie struct {
	*xgb.Cookie
}

// GetMap sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetMapCookie.Reply()
func GetMap(c *xgb.Conn, DeviceSpec DeviceSpec, Full uint16, Partial uint16, FirstType byte, NTypes byte, FirstKeySym xproto.Keycode, NKeySyms byte, FirstKeyAction xproto.Keycode, NKeyActions byte, FirstKeyBehavior xproto.Keycode, NKeyBehaviors byte, VirtualMods uint16, FirstKeyExplicit xproto.Keycode, NKeyExplicit byte, FirstModMapKey xproto.Keycode, NModMapKeys byte, FirstVModMapKey xproto.Keycode, NVModMapKeys byte) GetMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMapRequest(c, DeviceSpec, Full, Partial, FirstType, NTypes, FirstKeySym, NKeySyms, FirstKeyAction, NKeyActions, FirstKeyBehavior, NKeyBehaviors, VirtualMods, FirstKeyExplicit, NKeyExplicit, FirstModMapKey, NModMapKeys, FirstVModMapKey, NVModMapKeys), cookie)
	return GetMapCookie{cookie}
}

// GetMapUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetMapUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, Full uint16, Partial uint16, FirstType byte, NTypes byte, FirstKeySym xproto.Keycode, NKeySyms byte, FirstKeyAction xproto.Keycode, NKeyActions byte, FirstKeyBehavior xproto.Keycode, NKeyBehaviors byte, VirtualMods uint16, FirstKeyExplicit xproto.Keycode, NKeyExplicit byte, FirstModMapKey xproto.Keycode, NModMapKeys byte, FirstVModMapKey xproto.Keycode, NVModMapKeys byte) GetMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMapRequest(c, DeviceSpec, Full, Partial, FirstType, NTypes, FirstKeySym, NKeySyms, FirstKeyAction, NKeyActions, FirstKeyBehavior, NKeyBehaviors, VirtualMods, FirstKeyExplicit, NKeyExplicit, FirstModMapKey, NModMapKeys, FirstVModMapKey, NVModMapKeys), cookie)
	return GetMapCookie{cookie}
}

// GetMapReply represents the data returned from a GetMap request.
type GetMapReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	DeviceID byte
	// padding: 2 bytes
	MinKeyCode        xproto.Keycode
	MaxKeyCode        xproto.Keycode
	Present           uint16
	FirstType         byte
	NTypes            byte
	TotalTypes        byte
	FirstKeySym       xproto.Keycode
	TotalSyms         uint16
	NKeySyms          byte
	FirstKeyAction    xproto.Keycode
	TotalActions      uint16
	NKeyActions       byte
	FirstKeyBehavior  xproto.Keycode
	NKeyBehaviors     byte
	TotalKeyBehaviors byte
	FirstKeyExplicit  xproto.Keycode
	NKeyExplicit      byte
	TotalKeyExplicit  byte
	FirstModMapKey    xproto.Keycode
	NModMapKeys       byte
	TotalModMapKeys   byte
	FirstVModMapKey   xproto.Keycode
	NVModMapKeys      byte
	TotalVModMapKeys  byte
	// padding: 1 bytes
	VirtualMods uint16
	Map         []uint32
}

// Reply blocks and returns the reply data for a GetMap request.
func (cook GetMapCookie) Reply() (*GetMapReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMapReply(buf), nil
}

// getMapReply reads a byte slice into a GetMapReply value.
func getMapReply(buf []byte) *GetMapReply {
	v := new(GetMapReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 2 // padding

	v.MinKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.MaxKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.Present = xgb.Get16(buf[b:])
	b += 2

	v.FirstType = buf[b]
	b += 1

	v.NTypes = buf[b]
	b += 1

	v.TotalTypes = buf[b]
	b += 1

	v.FirstKeySym = xproto.Keycode(buf[b])
	b += 1

	v.TotalSyms = xgb.Get16(buf[b:])
	b += 2

	v.NKeySyms = buf[b]
	b += 1

	v.FirstKeyAction = xproto.Keycode(buf[b])
	b += 1

	v.TotalActions = xgb.Get16(buf[b:])
	b += 2

	v.NKeyActions = buf[b]
	b += 1

	v.FirstKeyBehavior = xproto.Keycode(buf[b])
	b += 1

	v.NKeyBehaviors = buf[b]
	b += 1

	v.TotalKeyBehaviors = buf[b]
	b += 1

	v.FirstKeyExplicit = xproto.Keycode(buf[b])
	b += 1

	v.NKeyExplicit = buf[b]
	b += 1

	v.TotalKeyExplicit = buf[b]
	b += 1

	v.FirstModMapKey = xproto.Keycode(buf[b])
	b += 1

	v.NModMapKeys = buf[b]
	b += 1

	v.TotalModMapKeys = buf[b]
	b += 1

	v.FirstVModMapKey = xproto.Keycode(buf[b])
	b += 1

	v.NVModMapKeys = buf[b]
	b += 1

	v.TotalVModMapKeys = buf[b]
	b += 1

	b += 1 // padding

	v.VirtualMods = xgb.Get16(buf[b:])
	b += 2

	v.Map = make([]uint32, xgb.PopCount(int(v.Present)))
	for i := 0; i < xgb.PopCount(int(v.Present)); i++ {
		v.Map[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetMap
// getMapRequest writes a GetMap request to a byte slice.
func getMapRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Full uint16, Partial uint16, FirstType byte, NTypes byte, FirstKeySym xproto.Keycode, NKeySyms byte, FirstKeyAction xproto.Keycode, NKeyActions byte, FirstKeyBehavior xproto.Keycode, NKeyBehaviors byte, VirtualMods uint16, FirstKeyExplicit xproto.Keycode, NKeyExplicit byte, FirstModMapKey xproto.Keycode, NModMapKeys byte, FirstVModMapKey xproto.Keycode, NVModMapKeys byte) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], Full)
	b += 2

	xgb.Put16(buf[b:], Partial)
	b += 2

	buf[b] = FirstType
	b += 1

	buf[b] = NTypes
	b += 1

	buf[b] = byte(FirstKeySym)
	b += 1

	buf[b] = NKeySyms
	b += 1

	buf[b] = byte(FirstKeyAction)
	b += 1

	buf[b] = NKeyActions
	b += 1

	buf[b] = byte(FirstKeyBehavior)
	b += 1

	buf[b] = NKeyBehaviors
	b += 1

	xgb.Put16(buf[b:], VirtualMods)
	b += 2

	buf[b] = byte(FirstKeyExplicit)
	b += 1

	buf[b] = NKeyExplicit
	b += 1

	buf[b] = byte(FirstModMapKey)
	b += 1

	buf[b] = NModMapKeys
	b += 1

	buf[b] = byte(FirstVModMapKey)
	b += 1

	buf[b] = NVModMapKeys
	b += 1

	b += 2 // padding

	return buf
}

// GetNamedIndicatorCookie is a cookie used only for GetNamedIndicator requests.
type GetNamedIndicatorCookie struct {
	*xgb.Cookie
}

// GetNamedIndicator sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetNamedIndicatorCookie.Reply()
func GetNamedIndicator(c *xgb.Conn, DeviceSpec DeviceSpec, LedClass LedClassSpec, LedID IDSpec, Indicator xproto.Atom) GetNamedIndicatorCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetNamedIndicator' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getNamedIndicatorRequest(c, DeviceSpec, LedClass, LedID, Indicator), cookie)
	return GetNamedIndicatorCookie{cookie}
}

// GetNamedIndicatorUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetNamedIndicatorUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, LedClass LedClassSpec, LedID IDSpec, Indicator xproto.Atom) GetNamedIndicatorCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetNamedIndicator' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getNamedIndicatorRequest(c, DeviceSpec, LedClass, LedID, Indicator), cookie)
	return GetNamedIndicatorCookie{cookie}
}

// GetNamedIndicatorReply represents the data returned from a GetNamedIndicator request.
type GetNamedIndicatorReply struct {
	Sequence       uint16 // sequence number of the request for this reply
	Length         uint32 // number of bytes in this reply
	DeviceID       byte
	Indicator      xproto.Atom
	Found          bool
	On             bool
	RealIndicator  bool
	Ndx            byte
	MapFlags       byte
	MapWhichgroups byte
	MapGroups      byte
	MapWhichmods   byte
	MapMods        byte
	MapRealmods    byte
	MapVmod        uint16
	MapCtrls       uint32
	Supported      bool
	// padding: 3 bytes
}

// Reply blocks and returns the reply data for a GetNamedIndicator request.
func (cook GetNamedIndicatorCookie) Reply() (*GetNamedIndicatorReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getNamedIndicatorReply(buf), nil
}

// getNamedIndicatorReply reads a byte slice into a GetNamedIndicatorReply value.
func getNamedIndicatorReply(buf []byte) *GetNamedIndicatorReply {
	v := new(GetNamedIndicatorReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Indicator = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	if buf[b] == 1 {
		v.Found = true
	} else {
		v.Found = false
	}
	b += 1

	if buf[b] == 1 {
		v.On = true
	} else {
		v.On = false
	}
	b += 1

	if buf[b] == 1 {
		v.RealIndicator = true
	} else {
		v.RealIndicator = false
	}
	b += 1

	v.Ndx = buf[b]
	b += 1

	v.MapFlags = buf[b]
	b += 1

	v.MapWhichgroups = buf[b]
	b += 1

	v.MapGroups = buf[b]
	b += 1

	v.MapWhichmods = buf[b]
	b += 1

	v.MapMods = buf[b]
	b += 1

	v.MapRealmods = buf[b]
	b += 1

	v.MapVmod = xgb.Get16(buf[b:])
	b += 2

	v.MapCtrls = xgb.Get32(buf[b:])
	b += 4

	if buf[b] == 1 {
		v.Supported = true
	} else {
		v.Supported = false
	}
	b += 1

	b += 3 // padding

	return v
}

// Write request to wire for GetNamedIndicator
// getNamedIndicatorRequest writes a GetNamedIndicator request to a byte slice.
func getNamedIndicatorRequest(c *xgb.Conn, DeviceSpec DeviceSpec, LedClass LedClassSpec, LedID IDSpec, Indicator xproto.Atom) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], uint16(LedClass))
	b += 2

	xgb.Put16(buf[b:], uint16(LedID))
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], uint32(Indicator))
	b += 4

	return buf
}

// GetNamesCookie is a cookie used only for GetNames requests.
type GetNamesCookie struct {
	*xgb.Cookie
}

// GetNames sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetNamesCookie.Reply()
func GetNames(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32) GetNamesCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetNames' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getNamesRequest(c, DeviceSpec, Which), cookie)
	return GetNamesCookie{cookie}
}

// GetNamesUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetNamesUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32) GetNamesCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetNames' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getNamesRequest(c, DeviceSpec, Which), cookie)
	return GetNamesCookie{cookie}
}

// GetNamesReply represents the data returned from a GetNames request.
type GetNamesReply struct {
	Sequence     uint16 // sequence number of the request for this reply
	Length       uint32 // number of bytes in this reply
	DeviceID     byte
	Which        uint32
	MinKeyCode   xproto.Keycode
	MaxKeyCode   xproto.Keycode
	NTypes       byte
	GroupNames   byte
	VirtualMods  uint16
	FirstKey     xproto.Keycode
	NKeys        byte
	Indicators   uint32
	NRadioGroups byte
	NKeyAliases  byte
	NKTLevels    uint16
	// padding: 4 bytes
	ValueList []uint32
}

// Reply blocks and returns the reply data for a GetNames request.
func (cook GetNamesCookie) Reply() (*GetNamesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getNamesReply(buf), nil
}

// getNamesReply reads a byte slice into a GetNamesReply value.
func getNamesReply(buf []byte) *GetNamesReply {
	v := new(GetNamesReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Which = xgb.Get32(buf[b:])
	b += 4

	v.MinKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.MaxKeyCode = xproto.Keycode(buf[b])
	b += 1

	v.NTypes = buf[b]
	b += 1

	v.GroupNames = buf[b]
	b += 1

	v.VirtualMods = xgb.Get16(buf[b:])
	b += 2

	v.FirstKey = xproto.Keycode(buf[b])
	b += 1

	v.NKeys = buf[b]
	b += 1

	v.Indicators = xgb.Get32(buf[b:])
	b += 4

	v.NRadioGroups = buf[b]
	b += 1

	v.NKeyAliases = buf[b]
	b += 1

	v.NKTLevels = xgb.Get16(buf[b:])
	b += 2

	b += 4 // padding

	v.ValueList = make([]uint32, xgb.PopCount(int(v.Which)))
	for i := 0; i < xgb.PopCount(int(v.Which)); i++ {
		v.ValueList[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetNames
// getNamesRequest writes a GetNames request to a byte slice.
func getNamesRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], Which)
	b += 4

	return buf
}

// GetStateCookie is a cookie used only for GetState requests.
type GetStateCookie struct {
	*xgb.Cookie
}

// GetState sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetStateCookie.Reply()
func GetState(c *xgb.Conn, DeviceSpec DeviceSpec) GetStateCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetState' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getStateRequest(c, DeviceSpec), cookie)
	return GetStateCookie{cookie}
}

// GetStateUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetStateUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec) GetStateCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'GetState' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getStateRequest(c, DeviceSpec), cookie)
	return GetStateCookie{cookie}
}

// GetStateReply represents the data returned from a GetState request.
type GetStateReply struct {
	Sequence         uint16 // sequence number of the request for this reply
	Length           uint32 // number of bytes in this reply
	DeviceID         byte
	Mods             byte
	BaseMods         byte
	LatchedMods      byte
	LockedMods       byte
	Group            byte
	LockedGroup      byte
	BaseGroup        int16
	LatchedGroup     int16
	CompatState      byte
	GrabMods         byte
	CompatGrabMods   byte
	LookupMods       byte
	CompatLookupMods byte
	// padding: 1 bytes
	PtrBtnState uint16
	// padding: 6 bytes
}

// Reply blocks and returns the reply data for a GetState request.
func (cook GetStateCookie) Reply() (*GetStateReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getStateReply(buf), nil
}

// getStateReply reads a byte slice into a GetStateReply value.
func getStateReply(buf []byte) *GetStateReply {
	v := new(GetStateReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Mods = buf[b]
	b += 1

	v.BaseMods = buf[b]
	b += 1

	v.LatchedMods = buf[b]
	b += 1

	v.LockedMods = buf[b]
	b += 1

	v.Group = buf[b]
	b += 1

	v.LockedGroup = buf[b]
	b += 1

	v.BaseGroup = int16(xgb.Get16(buf[b:]))
	b += 2

	v.LatchedGroup = int16(xgb.Get16(buf[b:]))
	b += 2

	v.CompatState = buf[b]
	b += 1

	v.GrabMods = buf[b]
	b += 1

	v.CompatGrabMods = buf[b]
	b += 1

	v.LookupMods = buf[b]
	b += 1

	v.CompatLookupMods = buf[b]
	b += 1

	b += 1 // padding

	v.PtrBtnState = xgb.Get16(buf[b:])
	b += 2

	b += 6 // padding

	return v
}

// Write request to wire for GetState
// getStateRequest writes a GetState request to a byte slice.
func getStateRequest(c *xgb.Conn, DeviceSpec DeviceSpec) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	b += 2 // padding

	return buf
}

// LatchLockStateCookie is a cookie used only for LatchLockState requests.
type LatchLockStateCookie struct {
	*xgb.Cookie
}

// LatchLockState sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func LatchLockState(c *xgb.Conn, DeviceSpec DeviceSpec, AffectModLocks byte, ModLocks byte, LockGroup bool, GroupLock byte, AffectModLatches byte, LatchGroup bool, GroupLatch uint16) LatchLockStateCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'LatchLockState' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(latchLockStateRequest(c, DeviceSpec, AffectModLocks, ModLocks, LockGroup, GroupLock, AffectModLatches, LatchGroup, GroupLatch), cookie)
	return LatchLockStateCookie{cookie}
}

// LatchLockStateChecked sends a checked request.
// If an error occurs, it can be retrieved using LatchLockStateCookie.Check()
func LatchLockStateChecked(c *xgb.Conn, DeviceSpec DeviceSpec, AffectModLocks byte, ModLocks byte, LockGroup bool, GroupLock byte, AffectModLatches byte, LatchGroup bool, GroupLatch uint16) LatchLockStateCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'LatchLockState' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(latchLockStateRequest(c, DeviceSpec, AffectModLocks, ModLocks, LockGroup, GroupLock, AffectModLatches, LatchGroup, GroupLatch), cookie)
	return LatchLockStateCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook LatchLockStateCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for LatchLockState
// latchLockStateRequest writes a LatchLockState request to a byte slice.
func latchLockStateRequest(c *xgb.Conn, DeviceSpec DeviceSpec, AffectModLocks byte, ModLocks byte, LockGroup bool, GroupLock byte, AffectModLatches byte, LatchGroup bool, GroupLatch uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	buf[b] = AffectModLocks
	b += 1

	buf[b] = ModLocks
	b += 1

	if LockGroup {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = GroupLock
	b += 1

	buf[b] = AffectModLatches
	b += 1

	b += 1 // padding

	b += 1 // padding

	if LatchGroup {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], GroupLatch)
	b += 2

	return buf
}

// ListComponentsCookie is a cookie used only for ListComponents requests.
type ListComponentsCookie struct {
	*xgb.Cookie
}

// ListComponents sends a checked request.
// If an error occurs, it will be returned with the reply by calling ListComponentsCookie.Reply()
func ListComponents(c *xgb.Conn, DeviceSpec DeviceSpec, MaxNames uint16) ListComponentsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'ListComponents' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(listComponentsRequest(c, DeviceSpec, MaxNames), cookie)
	return ListComponentsCookie{cookie}
}

// ListComponentsUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ListComponentsUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, MaxNames uint16) ListComponentsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'ListComponents' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(listComponentsRequest(c, DeviceSpec, MaxNames), cookie)
	return ListComponentsCookie{cookie}
}

// ListComponentsReply represents the data returned from a ListComponents request.
type ListComponentsReply struct {
	Sequence    uint16 // sequence number of the request for this reply
	Length      uint32 // number of bytes in this reply
	DeviceID    byte
	NKeymaps    uint16
	NKeycodes   uint16
	NTypes      uint16
	NCompatMaps uint16
	NSymbols    uint16
	NGeometries uint16
	Extra       uint16
	// padding: 10 bytes
	Keymaps    []Listing // size: ListingListSize(Keymaps)
	Keycodes   []Listing // size: ListingListSize(Keycodes)
	Types      []Listing // size: ListingListSize(Types)
	CompatMaps []Listing // size: ListingListSize(CompatMaps)
	Symbols    []Listing // size: ListingListSize(Symbols)
	Geometries []Listing // size: ListingListSize(Geometries)
}

// Reply blocks and returns the reply data for a ListComponents request.
func (cook ListComponentsCookie) Reply() (*ListComponentsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listComponentsReply(buf), nil
}

// listComponentsReply reads a byte slice into a ListComponentsReply value.
func listComponentsReply(buf []byte) *ListComponentsReply {
	v := new(ListComponentsReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NKeymaps = xgb.Get16(buf[b:])
	b += 2

	v.NKeycodes = xgb.Get16(buf[b:])
	b += 2

	v.NTypes = xgb.Get16(buf[b:])
	b += 2

	v.NCompatMaps = xgb.Get16(buf[b:])
	b += 2

	v.NSymbols = xgb.Get16(buf[b:])
	b += 2

	v.NGeometries = xgb.Get16(buf[b:])
	b += 2

	v.Extra = xgb.Get16(buf[b:])
	b += 2

	b += 10 // padding

	v.Keymaps = make([]Listing, v.NKeymaps)
	b += ListingReadList(buf[b:], v.Keymaps)

	v.Keycodes = make([]Listing, v.NKeycodes)
	b += ListingReadList(buf[b:], v.Keycodes)

	v.Types = make([]Listing, v.NTypes)
	b += ListingReadList(buf[b:], v.Types)

	v.CompatMaps = make([]Listing, v.NCompatMaps)
	b += ListingReadList(buf[b:], v.CompatMaps)

	v.Symbols = make([]Listing, v.NSymbols)
	b += ListingReadList(buf[b:], v.Symbols)

	v.Geometries = make([]Listing, v.NGeometries)
	b += ListingReadList(buf[b:], v.Geometries)

	return v
}

// Write request to wire for ListComponents
// listComponentsRequest writes a ListComponents request to a byte slice.
func listComponentsRequest(c *xgb.Conn, DeviceSpec DeviceSpec, MaxNames uint16) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], MaxNames)
	b += 2

	return buf
}

// PerClientFlagsCookie is a cookie used only for PerClientFlags requests.
type PerClientFlagsCookie struct {
	*xgb.Cookie
}

// PerClientFlags sends a checked request.
// If an error occurs, it will be returned with the reply by calling PerClientFlagsCookie.Reply()
func PerClientFlags(c *xgb.Conn, DeviceSpec DeviceSpec, Change uint32, Value uint32, CtrlsToChange uint32, AutoCtrls uint32, AutoCtrlsValues uint32) PerClientFlagsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'PerClientFlags' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(perClientFlagsRequest(c, DeviceSpec, Change, Value, CtrlsToChange, AutoCtrls, AutoCtrlsValues), cookie)
	return PerClientFlagsCookie{cookie}
}

// PerClientFlagsUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func PerClientFlagsUnchecked(c *xgb.Conn, DeviceSpec DeviceSpec, Change uint32, Value uint32, CtrlsToChange uint32, AutoCtrls uint32, AutoCtrlsValues uint32) PerClientFlagsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'PerClientFlags' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(perClientFlagsRequest(c, DeviceSpec, Change, Value, CtrlsToChange, AutoCtrls, AutoCtrlsValues), cookie)
	return PerClientFlagsCookie{cookie}
}

// PerClientFlagsReply represents the data returned from a PerClientFlags request.
type PerClientFlagsReply struct {
	Sequence        uint16 // sequence number of the request for this reply
	Length          uint32 // number of bytes in this reply
	DeviceID        byte
	Supported       uint32
	Value           uint32
	AutoCtrls       uint32
	AutoCtrlsValues uint32
	// padding: 8 bytes
}

// Reply blocks and returns the reply data for a PerClientFlags request.
func (cook PerClientFlagsCookie) Reply() (*PerClientFlagsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return perClientFlagsReply(buf), nil
}

// perClientFlagsReply reads a byte slice into a PerClientFlagsReply value.
func perClientFlagsReply(buf []byte) *PerClientFlagsReply {
	v := new(PerClientFlagsReply)
	b := 1 // skip reply determinant

	v.DeviceID = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Supported = xgb.Get32(buf[b:])
	b += 4

	v.Value = xgb.Get32(buf[b:])
	b += 4

	v.AutoCtrls = xgb.Get32(buf[b:])
	b += 4

	v.AutoCtrlsValues = xgb.Get32(buf[b:])
	b += 4

	b += 8 // padding

	return v
}

// Write request to wire for PerClientFlags
// perClientFlagsRequest writes a PerClientFlags request to a byte slice.
func perClientFlagsRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Change uint32, Value uint32, CtrlsToChange uint32, AutoCtrls uint32, AutoCtrlsValues uint32) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], Change)
	b += 4

	xgb.Put32(buf[b:], Value)
	b += 4

	xgb.Put32(buf[b:], CtrlsToChange)
	b += 4

	xgb.Put32(buf[b:], AutoCtrls)
	b += 4

	xgb.Put32(buf[b:], AutoCtrlsValues)
	b += 4

	return buf
}

// SelectEventsCookie is a cookie used only for SelectEvents requests.
type SelectEventsCookie struct {
	*xgb.Cookie
}

// SelectEvents sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SelectEvents(c *xgb.Conn, DeviceSpec DeviceSpec, AffectWhich uint16, Clear uint16, SelectAll uint16, AffectMap uint16, Map uint16, Details []uint32) SelectEventsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SelectEvents' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(selectEventsRequest(c, DeviceSpec, AffectWhich, Clear, SelectAll, AffectMap, Map, Details), cookie)
	return SelectEventsCookie{cookie}
}

// SelectEventsChecked sends a checked request.
// If an error occurs, it can be retrieved using SelectEventsCookie.Check()
func SelectEventsChecked(c *xgb.Conn, DeviceSpec DeviceSpec, AffectWhich uint16, Clear uint16, SelectAll uint16, AffectMap uint16, Map uint16, Details []uint32) SelectEventsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SelectEvents' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(selectEventsRequest(c, DeviceSpec, AffectWhich, Clear, SelectAll, AffectMap, Map, Details), cookie)
	return SelectEventsCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SelectEventsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SelectEvents
// selectEventsRequest writes a SelectEvents request to a byte slice.
func selectEventsRequest(c *xgb.Conn, DeviceSpec DeviceSpec, AffectWhich uint16, Clear uint16, SelectAll uint16, AffectMap uint16, Map uint16, Details []uint32) []byte {
	size := xgb.Pad((16 + xgb.Pad((4 * xgb.PopCount(int((int(AffectWhich) & ((^(Clear)) & (^(SelectAll))))))))))
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], AffectWhich)
	b += 2

	xgb.Put16(buf[b:], Clear)
	b += 2

	xgb.Put16(buf[b:], SelectAll)
	b += 2

	xgb.Put16(buf[b:], AffectMap)
	b += 2

	xgb.Put16(buf[b:], Map)
	b += 2

	for i := 0; i < xgb.PopCount(int((int(AffectWhich) & ((^(Clear)) & (^(SelectAll)))))); i++ {
		xgb.Put32(buf[b:], Details[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// SetCompatMapCookie is a cookie used only for SetCompatMap requests.
type SetCompatMapCookie struct {
	*xgb.Cookie
}

// SetCompatMap sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetCompatMap(c *xgb.Conn, DeviceSpec DeviceSpec, RecomputeActions bool, TruncateSI bool, Groups byte, FirstSI uint16, NSI uint16, Si []SymInterpret, GroupMaps []ModDef) SetCompatMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetCompatMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setCompatMapRequest(c, DeviceSpec, RecomputeActions, TruncateSI, Groups, FirstSI, NSI, Si, GroupMaps), cookie)
	return SetCompatMapCookie{cookie}
}

// SetCompatMapChecked sends a checked request.
// If an error occurs, it can be retrieved using SetCompatMapCookie.Check()
func SetCompatMapChecked(c *xgb.Conn, DeviceSpec DeviceSpec, RecomputeActions bool, TruncateSI bool, Groups byte, FirstSI uint16, NSI uint16, Si []SymInterpret, GroupMaps []ModDef) SetCompatMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetCompatMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setCompatMapRequest(c, DeviceSpec, RecomputeActions, TruncateSI, Groups, FirstSI, NSI, Si, GroupMaps), cookie)
	return SetCompatMapCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetCompatMapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetCompatMap
// setCompatMapRequest writes a SetCompatMap request to a byte slice.
func setCompatMapRequest(c *xgb.Conn, DeviceSpec DeviceSpec, RecomputeActions bool, TruncateSI bool, Groups byte, FirstSI uint16, NSI uint16, Si []SymInterpret, GroupMaps []ModDef) []byte {
	size := xgb.Pad(((16 + xgb.Pad((int(NSI) * 17))) + xgb.Pad((xgb.PopCount(Groups) * 4))))
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	b += 1 // padding

	if RecomputeActions {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if TruncateSI {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = Groups
	b += 1

	xgb.Put16(buf[b:], FirstSI)
	b += 2

	xgb.Put16(buf[b:], NSI)
	b += 2

	b += 2 // padding

	b += SymInterpretListBytes(buf[b:], Si)

	b += ModDefListBytes(buf[b:], GroupMaps)

	return buf
}

// SetControlsCookie is a cookie used only for SetControls requests.
type SetControlsCookie struct {
	*xgb.Cookie
}

// SetControls sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetControls(c *xgb.Conn, DeviceSpec DeviceSpec, AffectInternalRealMods byte, InternalRealMods byte, AffectIgnoreLockRealMods byte, IgnoreLockRealMods byte, AffectInternalVirtualMods uint16, InternalVirtualMods uint16, AffectIgnoreLockVirtualMods uint16, IgnoreLockVirtualMods uint16, MouseKeysDfltBtn byte, GroupsWrap byte, AccessXOptions uint16, AffectEnabledControls uint32, EnabledControls uint32, ChangeControls uint32, RepeatDelay uint16, RepeatInterval uint16, SlowKeysDelay uint16, DebounceDelay uint16, MouseKeysDelay uint16, MouseKeysInterval uint16, MouseKeysTimeToMax uint16, MouseKeysMaxSpeed uint16, MouseKeysCurve int16, AccessXTimeout uint16, AccessXTimeoutMask uint32, AccessXTimeoutValues uint32, AccessXTimeoutOptionsMask uint16, AccessXTimeoutOptionsValues uint16, PerKeyRepeat []byte) SetControlsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetControls' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setControlsRequest(c, DeviceSpec, AffectInternalRealMods, InternalRealMods, AffectIgnoreLockRealMods, IgnoreLockRealMods, AffectInternalVirtualMods, InternalVirtualMods, AffectIgnoreLockVirtualMods, IgnoreLockVirtualMods, MouseKeysDfltBtn, GroupsWrap, AccessXOptions, AffectEnabledControls, EnabledControls, ChangeControls, RepeatDelay, RepeatInterval, SlowKeysDelay, DebounceDelay, MouseKeysDelay, MouseKeysInterval, MouseKeysTimeToMax, MouseKeysMaxSpeed, MouseKeysCurve, AccessXTimeout, AccessXTimeoutMask, AccessXTimeoutValues, AccessXTimeoutOptionsMask, AccessXTimeoutOptionsValues, PerKeyRepeat), cookie)
	return SetControlsCookie{cookie}
}

// SetControlsChecked sends a checked request.
// If an error occurs, it can be retrieved using SetControlsCookie.Check()
func SetControlsChecked(c *xgb.Conn, DeviceSpec DeviceSpec, AffectInternalRealMods byte, InternalRealMods byte, AffectIgnoreLockRealMods byte, IgnoreLockRealMods byte, AffectInternalVirtualMods uint16, InternalVirtualMods uint16, AffectIgnoreLockVirtualMods uint16, IgnoreLockVirtualMods uint16, MouseKeysDfltBtn byte, GroupsWrap byte, AccessXOptions uint16, AffectEnabledControls uint32, EnabledControls uint32, ChangeControls uint32, RepeatDelay uint16, RepeatInterval uint16, SlowKeysDelay uint16, DebounceDelay uint16, MouseKeysDelay uint16, MouseKeysInterval uint16, MouseKeysTimeToMax uint16, MouseKeysMaxSpeed uint16, MouseKeysCurve int16, AccessXTimeout uint16, AccessXTimeoutMask uint32, AccessXTimeoutValues uint32, AccessXTimeoutOptionsMask uint16, AccessXTimeoutOptionsValues uint16, PerKeyRepeat []byte) SetControlsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetControls' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setControlsRequest(c, DeviceSpec, AffectInternalRealMods, InternalRealMods, AffectIgnoreLockRealMods, IgnoreLockRealMods, AffectInternalVirtualMods, InternalVirtualMods, AffectIgnoreLockVirtualMods, IgnoreLockVirtualMods, MouseKeysDfltBtn, GroupsWrap, AccessXOptions, AffectEnabledControls, EnabledControls, ChangeControls, RepeatDelay, RepeatInterval, SlowKeysDelay, DebounceDelay, MouseKeysDelay, MouseKeysInterval, MouseKeysTimeToMax, MouseKeysMaxSpeed, MouseKeysCurve, AccessXTimeout, AccessXTimeoutMask, AccessXTimeoutValues, AccessXTimeoutOptionsMask, AccessXTimeoutOptionsValues, PerKeyRepeat), cookie)
	return SetControlsCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetControlsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetControls
// setControlsRequest writes a SetControls request to a byte slice.
func setControlsRequest(c *xgb.Conn, DeviceSpec DeviceSpec, AffectInternalRealMods byte, InternalRealMods byte, AffectIgnoreLockRealMods byte, IgnoreLockRealMods byte, AffectInternalVirtualMods uint16, InternalVirtualMods uint16, AffectIgnoreLockVirtualMods uint16, IgnoreLockVirtualMods uint16, MouseKeysDfltBtn byte, GroupsWrap byte, AccessXOptions uint16, AffectEnabledControls uint32, EnabledControls uint32, ChangeControls uint32, RepeatDelay uint16, RepeatInterval uint16, SlowKeysDelay uint16, DebounceDelay uint16, MouseKeysDelay uint16, MouseKeysInterval uint16, MouseKeysTimeToMax uint16, MouseKeysMaxSpeed uint16, MouseKeysCurve int16, AccessXTimeout uint16, AccessXTimeoutMask uint32, AccessXTimeoutValues uint32, AccessXTimeoutOptionsMask uint16, AccessXTimeoutOptionsValues uint16, PerKeyRepeat []byte) []byte {
	size := 100
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	buf[b] = AffectInternalRealMods
	b += 1

	buf[b] = InternalRealMods
	b += 1

	buf[b] = AffectIgnoreLockRealMods
	b += 1

	buf[b] = IgnoreLockRealMods
	b += 1

	xgb.Put16(buf[b:], AffectInternalVirtualMods)
	b += 2

	xgb.Put16(buf[b:], InternalVirtualMods)
	b += 2

	xgb.Put16(buf[b:], AffectIgnoreLockVirtualMods)
	b += 2

	xgb.Put16(buf[b:], IgnoreLockVirtualMods)
	b += 2

	buf[b] = MouseKeysDfltBtn
	b += 1

	buf[b] = GroupsWrap
	b += 1

	xgb.Put16(buf[b:], AccessXOptions)
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], AffectEnabledControls)
	b += 4

	xgb.Put32(buf[b:], EnabledControls)
	b += 4

	xgb.Put32(buf[b:], ChangeControls)
	b += 4

	xgb.Put16(buf[b:], RepeatDelay)
	b += 2

	xgb.Put16(buf[b:], RepeatInterval)
	b += 2

	xgb.Put16(buf[b:], SlowKeysDelay)
	b += 2

	xgb.Put16(buf[b:], DebounceDelay)
	b += 2

	xgb.Put16(buf[b:], MouseKeysDelay)
	b += 2

	xgb.Put16(buf[b:], MouseKeysInterval)
	b += 2

	xgb.Put16(buf[b:], MouseKeysTimeToMax)
	b += 2

	xgb.Put16(buf[b:], MouseKeysMaxSpeed)
	b += 2

	xgb.Put16(buf[b:], uint16(MouseKeysCurve))
	b += 2

	xgb.Put16(buf[b:], AccessXTimeout)
	b += 2

	xgb.Put32(buf[b:], AccessXTimeoutMask)
	b += 4

	xgb.Put32(buf[b:], AccessXTimeoutValues)
	b += 4

	xgb.Put16(buf[b:], AccessXTimeoutOptionsMask)
	b += 2

	xgb.Put16(buf[b:], AccessXTimeoutOptionsValues)
	b += 2

	copy(buf[b:], PerKeyRepeat[:32])
	b += int(32)

	return buf
}

// SetDebuggingFlagsCookie is a cookie used only for SetDebuggingFlags requests.
type SetDebuggingFlagsCookie struct {
	*xgb.Cookie
}

// SetDebuggingFlags sends a checked request.
// If an error occurs, it will be returned with the reply by calling SetDebuggingFlagsCookie.Reply()
func SetDebuggingFlags(c *xgb.Conn, MsgLength uint16, AffectFlags uint32, Flags uint32, AffectCtrls uint32, Ctrls uint32, Message []String8) SetDebuggingFlagsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetDebuggingFlags' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDebuggingFlagsRequest(c, MsgLength, AffectFlags, Flags, AffectCtrls, Ctrls, Message), cookie)
	return SetDebuggingFlagsCookie{cookie}
}

// SetDebuggingFlagsUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetDebuggingFlagsUnchecked(c *xgb.Conn, MsgLength uint16, AffectFlags uint32, Flags uint32, AffectCtrls uint32, Ctrls uint32, Message []String8) SetDebuggingFlagsCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetDebuggingFlags' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDebuggingFlagsRequest(c, MsgLength, AffectFlags, Flags, AffectCtrls, Ctrls, Message), cookie)
	return SetDebuggingFlagsCookie{cookie}
}

// SetDebuggingFlagsReply represents the data returned from a SetDebuggingFlags request.
type SetDebuggingFlagsReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	CurrentFlags   uint32
	CurrentCtrls   uint32
	SupportedFlags uint32
	SupportedCtrls uint32
	// padding: 8 bytes
}

// Reply blocks and returns the reply data for a SetDebuggingFlags request.
func (cook SetDebuggingFlagsCookie) Reply() (*SetDebuggingFlagsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDebuggingFlagsReply(buf), nil
}

// setDebuggingFlagsReply reads a byte slice into a SetDebuggingFlagsReply value.
func setDebuggingFlagsReply(buf []byte) *SetDebuggingFlagsReply {
	v := new(SetDebuggingFlagsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.CurrentFlags = xgb.Get32(buf[b:])
	b += 4

	v.CurrentCtrls = xgb.Get32(buf[b:])
	b += 4

	v.SupportedFlags = xgb.Get32(buf[b:])
	b += 4

	v.SupportedCtrls = xgb.Get32(buf[b:])
	b += 4

	b += 8 // padding

	return v
}

// Write request to wire for SetDebuggingFlags
// setDebuggingFlagsRequest writes a SetDebuggingFlags request to a byte slice.
func setDebuggingFlagsRequest(c *xgb.Conn, MsgLength uint16, AffectFlags uint32, Flags uint32, AffectCtrls uint32, Ctrls uint32, Message []String8) []byte {
	size := xgb.Pad((24 + xgb.Pad((int(MsgLength) * 1))))
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 101 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], MsgLength)
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], AffectFlags)
	b += 4

	xgb.Put32(buf[b:], Flags)
	b += 4

	xgb.Put32(buf[b:], AffectCtrls)
	b += 4

	xgb.Put32(buf[b:], Ctrls)
	b += 4

	for i := 0; i < int(MsgLength); i++ {
		buf[b] = byte(Message[i])
		b += 1
	}

	return buf
}

// SetDeviceInfoCookie is a cookie used only for SetDeviceInfo requests.
type SetDeviceInfoCookie struct {
	*xgb.Cookie
}

// SetDeviceInfo sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetDeviceInfo(c *xgb.Conn, DeviceSpec DeviceSpec, FirstBtn byte, NBtns byte, Change uint16, NDeviceLedFBs uint16, BtnActions []ActionUnion, Leds []DeviceLedInfo) SetDeviceInfoCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetDeviceInfo' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setDeviceInfoRequest(c, DeviceSpec, FirstBtn, NBtns, Change, NDeviceLedFBs, BtnActions, Leds), cookie)
	return SetDeviceInfoCookie{cookie}
}

// SetDeviceInfoChecked sends a checked request.
// If an error occurs, it can be retrieved using SetDeviceInfoCookie.Check()
func SetDeviceInfoChecked(c *xgb.Conn, DeviceSpec DeviceSpec, FirstBtn byte, NBtns byte, Change uint16, NDeviceLedFBs uint16, BtnActions []ActionUnion, Leds []DeviceLedInfo) SetDeviceInfoCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetDeviceInfo' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setDeviceInfoRequest(c, DeviceSpec, FirstBtn, NBtns, Change, NDeviceLedFBs, BtnActions, Leds), cookie)
	return SetDeviceInfoCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetDeviceInfoCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetDeviceInfo
// setDeviceInfoRequest writes a SetDeviceInfo request to a byte slice.
func setDeviceInfoRequest(c *xgb.Conn, DeviceSpec DeviceSpec, FirstBtn byte, NBtns byte, Change uint16, NDeviceLedFBs uint16, BtnActions []ActionUnion, Leds []DeviceLedInfo) []byte {
	size := xgb.Pad(((12 + xgb.Pad((int(NBtns) * 8))) + DeviceLedInfoListSize(Leds)))
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 25 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	buf[b] = FirstBtn
	b += 1

	buf[b] = NBtns
	b += 1

	xgb.Put16(buf[b:], Change)
	b += 2

	xgb.Put16(buf[b:], NDeviceLedFBs)
	b += 2

	b += ActionUnionListBytes(buf[b:], BtnActions)

	b += DeviceLedInfoListBytes(buf[b:], Leds)

	return buf
}

// SetIndicatorMapCookie is a cookie used only for SetIndicatorMap requests.
type SetIndicatorMapCookie struct {
	*xgb.Cookie
}

// SetIndicatorMap sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetIndicatorMap(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32, Maps []IndicatorMap) SetIndicatorMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetIndicatorMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setIndicatorMapRequest(c, DeviceSpec, Which, Maps), cookie)
	return SetIndicatorMapCookie{cookie}
}

// SetIndicatorMapChecked sends a checked request.
// If an error occurs, it can be retrieved using SetIndicatorMapCookie.Check()
func SetIndicatorMapChecked(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32, Maps []IndicatorMap) SetIndicatorMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetIndicatorMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setIndicatorMapRequest(c, DeviceSpec, Which, Maps), cookie)
	return SetIndicatorMapCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetIndicatorMapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetIndicatorMap
// setIndicatorMapRequest writes a SetIndicatorMap request to a byte slice.
func setIndicatorMapRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Which uint32, Maps []IndicatorMap) []byte {
	size := xgb.Pad((12 + xgb.Pad((xgb.PopCount(Which) * 12))))
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], Which)
	b += 4

	b += IndicatorMapListBytes(buf[b:], Maps)

	return buf
}

// SetMapCookie is a cookie used only for SetMap requests.
type SetMapCookie struct {
	*xgb.Cookie
}

// SetMap sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetMap(c *xgb.Conn, DeviceSpec DeviceSpec, Present uint16, Flags uint16, MinKeyCode xproto.Keycode, MaxKeyCode xproto.Keycode, FirstType byte, NTypes byte, FirstKeySym xproto.Keycode, NKeySyms byte, TotalSyms uint16, FirstKeyAction xproto.Keycode, NKeyActions byte, TotalActions uint16, FirstKeyBehavior xproto.Keycode, NKeyBehaviors byte, TotalKeyBehaviors byte, FirstKeyExplicit xproto.Keycode, NKeyExplicit byte, TotalKeyExplicit byte, FirstModMapKey xproto.Keycode, NModMapKeys byte, TotalModMapKeys byte, FirstVModMapKey xproto.Keycode, NVModMapKeys byte, TotalVModMapKeys byte, VirtualMods uint16, Values []uint32) SetMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setMapRequest(c, DeviceSpec, Present, Flags, MinKeyCode, MaxKeyCode, FirstType, NTypes, FirstKeySym, NKeySyms, TotalSyms, FirstKeyAction, NKeyActions, TotalActions, FirstKeyBehavior, NKeyBehaviors, TotalKeyBehaviors, FirstKeyExplicit, NKeyExplicit, TotalKeyExplicit, FirstModMapKey, NModMapKeys, TotalModMapKeys, FirstVModMapKey, NVModMapKeys, TotalVModMapKeys, VirtualMods, Values), cookie)
	return SetMapCookie{cookie}
}

// SetMapChecked sends a checked request.
// If an error occurs, it can be retrieved using SetMapCookie.Check()
func SetMapChecked(c *xgb.Conn, DeviceSpec DeviceSpec, Present uint16, Flags uint16, MinKeyCode xproto.Keycode, MaxKeyCode xproto.Keycode, FirstType byte, NTypes byte, FirstKeySym xproto.Keycode, NKeySyms byte, TotalSyms uint16, FirstKeyAction xproto.Keycode, NKeyActions byte, TotalActions uint16, FirstKeyBehavior xproto.Keycode, NKeyBehaviors byte, TotalKeyBehaviors byte, FirstKeyExplicit xproto.Keycode, NKeyExplicit byte, TotalKeyExplicit byte, FirstModMapKey xproto.Keycode, NModMapKeys byte, TotalModMapKeys byte, FirstVModMapKey xproto.Keycode, NVModMapKeys byte, TotalVModMapKeys byte, VirtualMods uint16, Values []uint32) SetMapCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetMap' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setMapRequest(c, DeviceSpec, Present, Flags, MinKeyCode, MaxKeyCode, FirstType, NTypes, FirstKeySym, NKeySyms, TotalSyms, FirstKeyAction, NKeyActions, TotalActions, FirstKeyBehavior, NKeyBehaviors, TotalKeyBehaviors, FirstKeyExplicit, NKeyExplicit, TotalKeyExplicit, FirstModMapKey, NModMapKeys, TotalModMapKeys, FirstVModMapKey, NVModMapKeys, TotalVModMapKeys, VirtualMods, Values), cookie)
	return SetMapCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetMapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetMap
// setMapRequest writes a SetMap request to a byte slice.
func setMapRequest(c *xgb.Conn, DeviceSpec DeviceSpec, Present uint16, Flags uint16, MinKeyCode xproto.Keycode, MaxKeyCode xproto.Keycode, FirstType byte, NTypes byte, FirstKeySym xproto.Keycode, NKeySyms byte, TotalSyms uint16, FirstKeyAction xproto.Keycode, NKeyActions byte, TotalActions uint16, FirstKeyBehavior xproto.Keycode, NKeyBehaviors byte, TotalKeyBehaviors byte, FirstKeyExplicit xproto.Keycode, NKeyExplicit byte, TotalKeyExplicit byte, FirstModMapKey xproto.Keycode, NModMapKeys byte, TotalModMapKeys byte, FirstVModMapKey xproto.Keycode, NVModMapKeys byte, TotalVModMapKeys byte, VirtualMods uint16, Values []uint32) []byte {
	size := xgb.Pad((36 + xgb.Pad((4 * xgb.PopCount(int(Present))))))
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], Present)
	b += 2

	xgb.Put16(buf[b:], Flags)
	b += 2

	buf[b] = byte(MinKeyCode)
	b += 1

	buf[b] = byte(MaxKeyCode)
	b += 1

	buf[b] = FirstType
	b += 1

	buf[b] = NTypes
	b += 1

	buf[b] = byte(FirstKeySym)
	b += 1

	buf[b] = NKeySyms
	b += 1

	xgb.Put16(buf[b:], TotalSyms)
	b += 2

	buf[b] = byte(FirstKeyAction)
	b += 1

	buf[b] = NKeyActions
	b += 1

	xgb.Put16(buf[b:], TotalActions)
	b += 2

	buf[b] = byte(FirstKeyBehavior)
	b += 1

	buf[b] = NKeyBehaviors
	b += 1

	buf[b] = TotalKeyBehaviors
	b += 1

	buf[b] = byte(FirstKeyExplicit)
	b += 1

	buf[b] = NKeyExplicit
	b += 1

	buf[b] = TotalKeyExplicit
	b += 1

	buf[b] = byte(FirstModMapKey)
	b += 1

	buf[b] = NModMapKeys
	b += 1

	buf[b] = TotalModMapKeys
	b += 1

	buf[b] = byte(FirstVModMapKey)
	b += 1

	buf[b] = NVModMapKeys
	b += 1

	buf[b] = TotalVModMapKeys
	b += 1

	xgb.Put16(buf[b:], VirtualMods)
	b += 2

	for i := 0; i < xgb.PopCount(int(Present)); i++ {
		xgb.Put32(buf[b:], Values[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// SetNamedIndicatorCookie is a cookie used only for SetNamedIndicator requests.
type SetNamedIndicatorCookie struct {
	*xgb.Cookie
}

// SetNamedIndicator sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetNamedIndicator(c *xgb.Conn, DeviceSpec DeviceSpec, LedClass LedClassSpec, LedID IDSpec, Indicator xproto.Atom, SetState bool, On bool, SetMap bool, CreateMap bool, MapFlags byte, MapWhichgroups byte, MapGroups byte, MapWhichmods byte, MapRealmods byte, MapVmods uint16, MapCtrls uint32) SetNamedIndicatorCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetNamedIndicator' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setNamedIndicatorRequest(c, DeviceSpec, LedClass, LedID, Indicator, SetState, On, SetMap, CreateMap, MapFlags, MapWhichgroups, MapGroups, MapWhichmods, MapRealmods, MapVmods, MapCtrls), cookie)
	return SetNamedIndicatorCookie{cookie}
}

// SetNamedIndicatorChecked sends a checked request.
// If an error occurs, it can be retrieved using SetNamedIndicatorCookie.Check()
func SetNamedIndicatorChecked(c *xgb.Conn, DeviceSpec DeviceSpec, LedClass LedClassSpec, LedID IDSpec, Indicator xproto.Atom, SetState bool, On bool, SetMap bool, CreateMap bool, MapFlags byte, MapWhichgroups byte, MapGroups byte, MapWhichmods byte, MapRealmods byte, MapVmods uint16, MapCtrls uint32) SetNamedIndicatorCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetNamedIndicator' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setNamedIndicatorRequest(c, DeviceSpec, LedClass, LedID, Indicator, SetState, On, SetMap, CreateMap, MapFlags, MapWhichgroups, MapGroups, MapWhichmods, MapRealmods, MapVmods, MapCtrls), cookie)
	return SetNamedIndicatorCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetNamedIndicatorCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetNamedIndicator
// setNamedIndicatorRequest writes a SetNamedIndicator request to a byte slice.
func setNamedIndicatorRequest(c *xgb.Conn, DeviceSpec DeviceSpec, LedClass LedClassSpec, LedID IDSpec, Indicator xproto.Atom, SetState bool, On bool, SetMap bool, CreateMap bool, MapFlags byte, MapWhichgroups byte, MapGroups byte, MapWhichmods byte, MapRealmods byte, MapVmods uint16, MapCtrls uint32) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], uint16(LedClass))
	b += 2

	xgb.Put16(buf[b:], uint16(LedID))
	b += 2

	b += 2 // padding

	xgb.Put32(buf[b:], uint32(Indicator))
	b += 4

	if SetState {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if On {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if SetMap {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if CreateMap {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	buf[b] = MapFlags
	b += 1

	buf[b] = MapWhichgroups
	b += 1

	buf[b] = MapGroups
	b += 1

	buf[b] = MapWhichmods
	b += 1

	buf[b] = MapRealmods
	b += 1

	xgb.Put16(buf[b:], MapVmods)
	b += 2

	xgb.Put32(buf[b:], MapCtrls)
	b += 4

	return buf
}

// SetNamesCookie is a cookie used only for SetNames requests.
type SetNamesCookie struct {
	*xgb.Cookie
}

// SetNames sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetNames(c *xgb.Conn, DeviceSpec DeviceSpec, VirtualMods uint16, Which uint32, FirstType byte, NTypes byte, FirstKTLevelt byte, NKTLevels byte, Indicators uint32, GroupNames byte, NRadioGroups byte, FirstKey xproto.Keycode, NKeys byte, NKeyAliases byte, TotalKTLevelNames uint16, Values []uint32) SetNamesCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetNames' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setNamesRequest(c, DeviceSpec, VirtualMods, Which, FirstType, NTypes, FirstKTLevelt, NKTLevels, Indicators, GroupNames, NRadioGroups, FirstKey, NKeys, NKeyAliases, TotalKTLevelNames, Values), cookie)
	return SetNamesCookie{cookie}
}

// SetNamesChecked sends a checked request.
// If an error occurs, it can be retrieved using SetNamesCookie.Check()
func SetNamesChecked(c *xgb.Conn, DeviceSpec DeviceSpec, VirtualMods uint16, Which uint32, FirstType byte, NTypes byte, FirstKTLevelt byte, NKTLevels byte, Indicators uint32, GroupNames byte, NRadioGroups byte, FirstKey xproto.Keycode, NKeys byte, NKeyAliases byte, TotalKTLevelNames uint16, Values []uint32) SetNamesCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'SetNames' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setNamesRequest(c, DeviceSpec, VirtualMods, Which, FirstType, NTypes, FirstKTLevelt, NKTLevels, Indicators, GroupNames, NRadioGroups, FirstKey, NKeys, NKeyAliases, TotalKTLevelNames, Values), cookie)
	return SetNamesCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetNamesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetNames
// setNamesRequest writes a SetNames request to a byte slice.
func setNamesRequest(c *xgb.Conn, DeviceSpec DeviceSpec, VirtualMods uint16, Which uint32, FirstType byte, NTypes byte, FirstKTLevelt byte, NKTLevels byte, Indicators uint32, GroupNames byte, NRadioGroups byte, FirstKey xproto.Keycode, NKeys byte, NKeyAliases byte, TotalKTLevelNames uint16, Values []uint32) []byte {
	size := xgb.Pad((28 + xgb.Pad((4 * xgb.PopCount(int(Which))))))
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(DeviceSpec))
	b += 2

	xgb.Put16(buf[b:], VirtualMods)
	b += 2

	xgb.Put32(buf[b:], Which)
	b += 4

	buf[b] = FirstType
	b += 1

	buf[b] = NTypes
	b += 1

	buf[b] = FirstKTLevelt
	b += 1

	buf[b] = NKTLevels
	b += 1

	xgb.Put32(buf[b:], Indicators)
	b += 4

	buf[b] = GroupNames
	b += 1

	buf[b] = NRadioGroups
	b += 1

	buf[b] = byte(FirstKey)
	b += 1

	buf[b] = NKeys
	b += 1

	buf[b] = NKeyAliases
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], TotalKTLevelNames)
	b += 2

	for i := 0; i < xgb.PopCount(int(Which)); i++ {
		xgb.Put32(buf[b:], Values[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// UseExtensionCookie is a cookie used only for UseExtension requests.
type UseExtensionCookie struct {
	*xgb.Cookie
}

// UseExtension sends a checked request.
// If an error occurs, it will be returned with the reply by calling UseExtensionCookie.Reply()
func UseExtension(c *xgb.Conn, WantedMajor uint16, WantedMinor uint16) UseExtensionCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'UseExtension' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(useExtensionRequest(c, WantedMajor, WantedMinor), cookie)
	return UseExtensionCookie{cookie}
}

// UseExtensionUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func UseExtensionUnchecked(c *xgb.Conn, WantedMajor uint16, WantedMinor uint16) UseExtensionCookie {
	c.ExtLock.RLock()
	defer c.ExtLock.RUnlock()
	if _, ok := c.Extensions["XKEYBOARD"]; !ok {
		panic("Cannot issue request 'UseExtension' using the uninitialized extension 'XKEYBOARD'. xkb.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(useExtensionRequest(c, WantedMajor, WantedMinor), cookie)
	return UseExtensionCookie{cookie}
}

// UseExtensionReply represents the data returned from a UseExtension request.
type UseExtensionReply struct {
	Sequence    uint16 // sequence number of the request for this reply
	Length      uint32 // number of bytes in this reply
	Supported   bool
	ServerMajor uint16
	ServerMinor uint16
	// padding: 20 bytes
}

// Reply blocks and returns the reply data for a UseExtension request.
func (cook UseExtensionCookie) Reply() (*UseExtensionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return useExtensionReply(buf), nil
}

// useExtensionReply reads a byte slice into a UseExtensionReply value.
func useExtensionReply(buf []byte) *UseExtensionReply {
	v := new(UseExtensionReply)
	b := 1 // skip reply determinant

	if buf[b] == 1 {
		v.Supported = true
	} else {
		v.Supported = false
	}
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ServerMajor = xgb.Get16(buf[b:])
	b += 2

	v.ServerMinor = xgb.Get16(buf[b:])
	b += 2

	b += 20 // padding

	return v
}

// Write request to wire for UseExtension
// useExtensionRequest writes a UseExtension request to a byte slice.
func useExtensionRequest(c *xgb.Conn, WantedMajor uint16, WantedMinor uint16) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	c.ExtLock.RLock()
	buf[b] = c.Extensions["XKEYBOARD"]
	c.ExtLock.RUnlock()
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], WantedMajor)
	b += 2

	xgb.Put16(buf[b:], WantedMinor)
	b += 2

	return buf
}
